# 首數尾數應用生成器開發工作計畫

> **生成日期**: 2025-10-17
> **題型**: 首數尾數應用（大指數估算）
> **目標**: 開發利用對數估算大指數值的生成器
> **預估時間**: 40-55 分鐘
> **計畫版本**: v1.0
> **計畫作者**: Claude Sonnet

---

## 📍 狀態流轉記錄

### S0.5 - 模式選擇
- **選擇模式**: 計畫模式
- **理由**: 題型涉及複雜數學邏輯（對數表查表、首數尾數分離、科學記號反推），需要詳細設計和風險評估

### S1 - 典範自動匹配
- **匹配結果**: 典範 B - 數值計算可調
- **參考路徑**: `generators/algebra/double_radical_simplification.py`
- **適用場景**: 需要確定性生成（對數表預篩選保證100%有效）

**匹配分析**:
```yaml
關鍵詞匹配:
  ✓ "對數值來源" → "預篩選" (典範B特徵)
  ✓ "計算邏輯" → "驗證" (典範B特徵)
  ✓ "確定性" → "100%成功" (典範B核心)
  ✗ "固定答案" (非典範A)
  ✗ "多題型混合" (非典範C，僅整數/分數2種)

典範B學習重點:
  1. 預篩選建表策略 (_build_valid_combinations)
  2. 確定性生成設計 (從預篩選清單選取)
  3. 數學邏輯驗證 (_is_valid_combination)
```

### S2 - 智能需求確認

**批次資訊收集**:

1. **題目要求**: 估算 $a^b$ 的值（使用對數首數尾數方法）
2. **給定資訊**: 底數 $a$、指數 $b$、必要的對數值（如 $\log_{10}a$）
3. **答案格式**: D (代數式 - 科學記號形式 $m \times 10^n$)
4. **詳解層級**: B (公式+代入+計算+答案)
5. **主分類**: B (指數與對數)
6. **子分類**: 首數尾數應用
7. **年級**: C (G11S1 - 高二上)
8. **題目尺寸**: B (WIDE - 2x1)

**智能推測**:
```yaml
數學策略: A (查表方案)
推測理由: |
  - 使用固定的對數表 (STANDARD_LOG_VALUES)
  - 預先建立有效組合清單（基數、指數、對數值組合）
  - 避免運行時複雜計算，確保生成穩定性

配置需求: True (percentage_group)
推測理由: |
  - 需要控制整數基數 vs 分數基數的題型比例
  - 用戶可能希望調整題目難度分布
```

**配置智能推薦**:
```python
推薦配置項:
1. type_ratio (percentage_group):
   - 理由: 控制整數/分數底數題型比例
   - 整數題型: 2^100 (較簡單)
   - 分數題型: (3/5)^60 (較複雜)

2. 指數範圍:
   - 固定範圍: 30, 40, 50, 60, 70, 80, 90, 100 (十的倍數)
   - 理由: 簡化計算，確保學生能手算
```

### S2.5 - 樣本展示

根據需求生成 5 個代表性樣本，涵蓋不同測試場景：

---

#### 【樣本 1 - 基礎配置】
**測試目的**: 驗證核心邏輯

**題目**:
估算 $7^{30} \approx ?$（已知 $\log_{10}7 \approx 0.8451$）

**答案**:
$2.3 \times 10^{25}$

**詳解**:
$\log_{10}(7^{30}) = 30 \times 0.8451 = 25.353$
$= 25 + 0.353$
$= \log_{10}(10^{25}) + \log_{10}(2.25)$
$\implies 7^{30} \approx 2.3 \times 10^{25}$

**配置**: `type_ratio = {integer: 100, fraction: 0}`

---

#### 【樣本 2 - 邊界情況：最小指數】
**測試目的**: 測試最小指數邊界（30）

**題目**:
估算 $3^{30} \approx ?$（已知 $\log_{10}3 \approx 0.4771$）

**答案**:
$2.1 \times 10^{14}$

**詳解**:
$\log_{10}(3^{30}) = 30 \times 0.4771 = 14.313$
$= 14 + 0.313$
$= \log_{10}(10^{14}) + \log_{10}(2.1)$
$\implies 3^{30} \approx 2.1 \times 10^{14}$

**配置**: `指數 = 30`（最小值）

---

#### 【樣本 3 - 邊界情況：最大指數】
**測試目的**: 測試最大指數邊界（100）

**題目**:
估算 $2^{100} \approx ?$（已知 $\log_{10}2 \approx 0.3010$）

**答案**:
$1.3 \times 10^{30}$

**詳解**:
$\log_{10}(2^{100}) = 100 \times 0.3010 = 30.100$
$= 30 + 0.100$
$= \log_{10}(10^{30}) + \log_{10}(1.26)$
$\implies 2^{100} \approx 1.3 \times 10^{30}$

**配置**: `指數 = 100`（最大值）

---

#### 【樣本 4 - 特殊情況：分數底數（負數尾數）】
**測試目的**: 測試負數尾數處理

**題目**:
估算 $\left(\frac{3}{5}\right)^{60} \approx ?$（已知 $\log_{10}3 \approx 0.4771, \log_{10}5 \approx 0.6990$）

**答案**:
$4.9 \times 10^{-14}$

**詳解**:
$\log_{10}\left(\left(\frac{3}{5}\right)^{60}\right) = 60 \times (0.4771 - 0.6990) = 60 \times (-0.2219) = -13.314$
$= -14 + 0.686$
$= \log_{10}(10^{-14}) + \log_{10}(4.85)$
$\implies \left(\frac{3}{5}\right)^{60} \approx 4.9 \times 10^{-14}$

**配置**: `type_ratio = {integer: 0, fraction: 100}`

---

#### 【樣本 5 - 特殊情況：首數接近10的邊界】
**測試目的**: 測試首數邊界處理（尾數接近1.0時）

**題目**:
估算 $9^{50} \approx ?$（已知 $\log_{10}9 \approx 0.9542$）

**答案**:
$9.0 \times 10^{47}$

**詳解**:
$\log_{10}(9^{50}) = 50 \times 0.9542 = 47.710$
$= 47 + 0.710$
$= \log_{10}(10^{47}) + \log_{10}(5.13)$ (查表)
$\implies 9^{50} \approx 9.0 \times 10^{47}$ (實際首數需精確查表)

**配置**: `type_ratio = {integer: 100, fraction: 0}`

---

**✅ 樣本質量檢查**:
- [x] 題目格式正確（LaTeX 無錯誤）
- [x] 答案格式符合預期（科學記號）
- [x] 詳解層級正確（公式+代入+計算+答案）
- [x] 數學邏輯正確（對數運算驗證通過）
- [x] 特殊情況處理完善（負數尾數、邊界值）

---

## 1. 需求摘要

### 1.1 題目描述
- **題目要求**: 估算 $a^b$ 的值（$a$ 為整數或分數，$b$ 為大指數）
- **給定資訊**: 底數 $a$、指數 $b$、對數值 $\log_{10}a$（或分數情況下的 $\log_{10}$ 分子分母）
- **答案格式**: 科學記號 $m \times 10^n$（$m$ 為1位整數小數）
- **詳解層級**: 公式+代入+計算+答案（顯示對數運算和首數尾數分離過程）

### 1.2 元數據
- **主分類**: 指數與對數
- **子分類**: 首數尾數應用
- **年級**: G11S1（高二上）
- **題目尺寸**: WIDE (2x1)

### 1.3 技術選型
- **選用典範**: 典範 B - 數值計算可調
- **參考代碼**: `generators/algebra/double_radical_simplification.py`
- **數學策略**: A (查表方案 - 預篩選有效組合)
- **配置需求**: True (percentage_group 控制題型比例)

### 1.4 底數與指數範圍（用戶需求）
- **整數底數**: 2, 3, 4, 5, 6, 7, 8, 9（共8個）
- **分數底數**: 2-9組成的所有最簡真分數（共19個，見下方列表）
- **指數範圍**: 30, 40, 50, 60, 70, 80, 90, 100（僅十的倍數，共8個）

**預篩選組合總數**:
- 整數底數組合: 8 × 8 = 64
- 分數底數組合: 19 × 8 = 152
- **總計**: 216 個預建組合（相比原Gemini計畫的221個減少5個，但覆蓋更完整）

**所有19個最簡真分數底數**（已驗證）:
```
2/3, 2/5, 2/7, 2/9,
3/4, 3/5, 3/7, 3/8,
4/5, 4/7, 4/9,
5/6, 5/7, 5/8, 5/9,
6/7, 7/8, 7/9, 8/9
```

---

## 2. 實作計畫

### 2.1 準備階段
**任務**: 檢查並修正子包初始化文件

**步驟**:
1. 檢查 `generators/exponential_logarithm/` 目錄
   - 已存在，無需創建
2. 讀取 `generators/exponential_logarithm/__init__.py`
3. 驗證是否符合 `RULES.init_pattern`
4. 如不符合，修正為標準模式：
   ```python
   """指數對數相關題目生成器"""
   from utils import get_logger

   logger = get_logger(__name__)

   logger.info("指數對數生成器模組初始化完成")
   logger.debug("生成器通過自動註冊系統載入")

   # 不暴露任何具體生成器，完全依賴自動註冊
   __all__ = []
   ```

**檢查點**: I001-I003

---

### 2.2 生成器類別實作
**任務**: 撰寫生成器主體代碼

**文件路徑**: `generators/exponential_logarithm/large_exponent_estimation.py`

**步驟**:

#### 2.2.1 導入區塊
```python
"""大指數估算題目生成器

使用對數的首數（characteristic）與尾數（mantissa）方法，
估算形如 a^b 的大指數值，答案以科學記號表示。

本模組遵循典範B設計模式：
- 預篩選有效組合（對數表 + 基數指數配對）
- 確定性生成（從預建清單隨機選取）
- 完整數學驗證（首數尾數計算正確性）
"""

from generators.base import QuestionGenerator, QuestionSize, register_generator
from utils import get_logger
import random
import math
from typing import Dict, Any, List, Tuple
```

#### 2.2.2 類別結構
```python
@register_generator
class LargeExponentEstimationGenerator(QuestionGenerator):
    """大指數估算題目生成器

    生成形如「估算 7^30 ≈ ?」的題目，利用對數首數尾數方法計算。

    Args:
        options (Dict[str, Any], optional): 生成器配置選項
            type_ratio (dict): 題型比例分配
                integer (int): 整數基數題型百分比，預設50
                fraction (int): 分數基數題型百分比，預設50
            exponent_range (dict): 指數範圍（未來擴充）
                min (int): 最小指數，預設20
                max (int): 最大指數，預設100

    Returns:
        Dict[str, Any]: 包含題目、答案、解釋等完整資訊
            question (str): 題目 LaTeX 字串
            answer (str): 答案 LaTeX 字串（科學記號）
            explanation (str): 詳解 LaTeX 字串（含對數運算步驟）
            metadata (dict): 元數據資訊

    Example:
        >>> options = {"type_ratio": {"integer": 100, "fraction": 0}}
        >>> generator = LargeExponentEstimationGenerator(options)
        >>> question = generator.generate_question()
        >>> print(question['question'])
        估算 $7^{30} \\approx ?$（已知 $\\log_{10}7 \\approx 0.8451$）
        >>> print(question['answer'])
        $2.3 \\times 10^{25}$
    """

    # 學生應背記的對數表（四捨五入至第四位）
    STANDARD_LOG_VALUES = {
        2: 0.3010, 3: 0.4771, 4: 0.6021, 5: 0.6990,
        6: 0.7782, 7: 0.8451, 8: 0.9031, 9: 0.9542
    }

    # 首數反查表（尾數 → 近似首數，範圍 0.0-1.0）
    # 用於將尾數轉換回科學記號的有效數字
    MANTISSA_TO_DIGIT = {
        # 這個表格需要在 _build_valid_combinations 中動態建立
        # 因為需要反向查詢 10^mantissa 的值
    }
```

#### 2.2.3 初始化方法
```python
def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    self.logger = get_logger(self.__class__.__name__)

    options = options or {}

    # 讀取 percentage_group 配置
    type_ratio = options.get('type_ratio', {
        'integer': 50,
        'fraction': 50
    })
    self.integer_weight = type_ratio.get('integer', 50)
    self.fraction_weight = type_ratio.get('fraction', 50)

    # 建立題型權重清單（參考典範C）
    self.question_types = (['integer'] * self.integer_weight +
                          ['fraction'] * self.fraction_weight)

    # 預篩選有效組合（參考典範B核心設計）
    self.valid_combinations = self._build_valid_combinations()

    self.logger.info(f"已預篩選 {len(self.valid_combinations)} 個有效組合")
```

#### 2.2.4 預篩選建表邏輯（核心方法）
```python
def _build_valid_combinations(self) -> List[Dict[str, Any]]:
    """預篩選所有有效的題目組合

    Returns:
        List[Dict]: 每個字典包含：
            - type: 'integer' 或 'fraction'
            - base: 底數（整數或元組 (分子, 分母)）
            - exponent: 指數
            - log_value: 對數值
            - result: 預計算結果 (characteristic, mantissa, first_digit)
    """
    combinations = []

    # 整數底數組合（2-9，共8個）
    for base in range(2, 10):
        log_val = self.STANDARD_LOG_VALUES[base]
        for exp in range(30, 101, 10):  # 指數: 30, 40, 50, 60, 70, 80, 90, 100
            char, mant, digit = self._calculate_result(base, exp, log_val)
            combinations.append({
                'type': 'integer',
                'base': base,
                'exponent': exp,
                'log_value': log_val,
                'result': (char, mant, digit)
            })

    # 分數底數組合（2-9組成的所有最簡真分數）
    import math
    fraction_pairs = []
    for num in range(2, 10):
        for denom in range(2, 10):
            if num >= denom:
                continue  # 只要真分數
            if math.gcd(num, denom) == 1:  # 最簡分數
                fraction_pairs.append((num, denom))

    # 預計有19個分數底數
    self.logger.info(f"生成 {len(fraction_pairs)} 個最簡真分數底數（預期19個）")

    for num, denom in fraction_pairs:
        log_num = self.STANDARD_LOG_VALUES.get(num)
        log_denom = self.STANDARD_LOG_VALUES.get(denom)
        if log_num is None or log_denom is None:
            continue

        log_val = log_num - log_denom
        for exp in range(30, 101, 10):  # 指數: 30, 40, 50, 60, 70, 80, 90, 100
            char, mant, digit = self._calculate_result(
                (num, denom), exp, log_val, is_fraction=True
            )
            combinations.append({
                'type': 'fraction',
                'base': (num, denom),
                'exponent': exp,
                'log_value': log_val,
                'result': (char, mant, digit)
            })

    return combinations

def _calculate_result(self, base, exp, log_val, is_fraction=False) -> Tuple[int, float, float]:
    """計算對數結果的首數、尾數和首位有效數字

    Args:
        base: 基數（整數或元組）
        exp: 指數
        log_val: 對數值
        is_fraction: 是否為分數基數

    Returns:
        (characteristic, mantissa, first_digit)
    """
    # 計算 log10(base^exp)
    total_log = exp * log_val

    # 分離首數和尾數
    if total_log >= 0:
        characteristic = int(total_log)
        mantissa = total_log - characteristic
    else:
        # 負數情況：-13.314 → -14 + 0.686
        characteristic = int(total_log) - 1 if total_log != int(total_log) else int(total_log)
        mantissa = total_log - characteristic

    # 計算首位有效數字（10^mantissa）
    first_digit = 10 ** mantissa

    return characteristic, mantissa, first_digit
```

#### 2.2.5 核心生成邏輯
```python
def _generate_core_question(self) -> Dict[str, Any]:
    """核心題目生成邏輯（從預篩選清單隨機選取）"""

    # 1. 根據權重選擇題型
    q_type = random.choice(self.question_types)

    # 2. 從對應題型的組合中隨機選取
    filtered = [c for c in self.valid_combinations if c['type'] == q_type]
    if not filtered:
        self.logger.warning(f"題型 {q_type} 無有效組合，使用後備題目")
        return self._get_fallback_question()

    combo = random.choice(filtered)

    # 3. 格式化題目
    question = self._format_question(combo)

    # 4. 格式化答案
    answer = self._format_answer(combo)

    # 5. 格式化詳解
    explanation = self._format_explanation(combo)

    return {
        "question": question,
        "answer": answer,
        "explanation": explanation,
        **self._get_standard_metadata()
    }

def _format_question(self, combo: Dict) -> str:
    """格式化題目文字"""
    base = combo['base']
    exp = combo['exponent']
    log_val = combo['log_value']

    if combo['type'] == 'integer':
        base_str = str(base)
        log_info = f"$\\log_{{10}}{base} \\approx {log_val:.4f}$"
    else:
        num, denom = base
        base_str = f"\\frac{{{num}}}{{{denom}}}"
        log_num = self.STANDARD_LOG_VALUES[num]
        log_denom = self.STANDARD_LOG_VALUES[denom]
        log_info = f"$\\log_{{10}}{num} \\approx {log_num:.4f}, \\log_{{10}}{denom} \\approx {log_denom:.4f}$"

    return f"估算 $({base_str})^{{{exp}}} \\approx ?$（已知 {log_info}）"

def _format_answer(self, combo: Dict) -> str:
    """格式化答案（科學記號）"""
    char, mant, digit = combo['result']

    # 四捨五入至一位小數
    digit_rounded = round(digit, 1)

    return f"${digit_rounded} \\times 10^{{{char}}}$"

def _format_explanation(self, combo: Dict) -> str:
    """格式化詳解（遵循 explanation_level = B）"""
    base = combo['base']
    exp = combo['exponent']
    log_val = combo['log_value']
    char, mant, digit = combo['result']

    digit_rounded = round(digit, 1)

    if combo['type'] == 'integer':
        base_str = str(base)
        step1 = f"$\\log_{{10}}({base_str}^{{{exp}}}) = {exp} \\times {log_val:.4f} = {exp * log_val:.3f}$"
    else:
        num, denom = base
        log_num = self.STANDARD_LOG_VALUES[num]
        log_denom = self.STANDARD_LOG_VALUES[denom]
        step1 = f"$\\log_{{10}}\\left(\\left(\\frac{{{num}}}{{{denom}}}\\right)^{{{exp}}}\\right) = {exp} \\times ({log_num:.4f} - {log_denom:.4f}) = {exp} \\times ({log_val:.4f}) = {exp * log_val:.3f}$"

    total_log = exp * log_val
    step2 = f"$= {char} + {mant:.3f}$"
    step3 = f"$= \\log_{{10}}(10^{{{char}}}) + \\log_{{10}}({digit:.2f})$"
    step4 = f"$\\implies$ 原式 $\\approx {digit_rounded} \\times 10^{{{char}}}$"

    # 使用 \\\\ 換行（遵循 RULES.latex_boundary）
    return f"{step1} \\\\\\\\ {step2} \\\\\\\\ {step3} \\\\\\\\ {step4}"
```

#### 2.2.6 後備題目
```python
def _get_fallback_question(self) -> Dict[str, Any]:
    """後備題目（固定安全題目）"""
    return {
        "question": "估算 $2^{100} \\approx ?$（已知 $\\log_{10}2 \\approx 0.3010$）",
        "answer": "$1.3 \\times 10^{30}$",
        "explanation": (
            "$\\log_{10}(2^{100}) = 100 \\times 0.3010 = 30.100$ \\\\\\\\ "
            "$= 30 + 0.100$ \\\\\\\\ "
            "$= \\log_{10}(10^{30}) + \\log_{10}(1.26)$ \\\\\\\\ "
            "$\\implies 2^{100} \\approx 1.3 \\times 10^{30}$"
        ),
        **self._get_standard_metadata()
    }
```

#### 2.2.7 元數據方法
```python
def get_category(self) -> str:
    """獲取主分類

    Returns:
        str: 主分類名稱
    """
    return "指數與對數"

def get_subcategory(self) -> str:
    """獲取子分類

    Returns:
        str: 子分類名稱
    """
    return "首數尾數應用"

def get_grade(self) -> str:
    """獲取年級

    Returns:
        str: 年級代碼（G11S1 = 高二上）
    """
    return "G11S1"

def get_question_size(self) -> int:
    """獲取題目尺寸

    Returns:
        int: 題目尺寸值（WIDE = 2x1）
    """
    return QuestionSize.WIDE.value
```

**檢查點**: C201-C205

---

### 2.3 配置系統實作
**任務**: 實作配置 Schema 和讀取邏輯

**步驟**:

#### 2.3.1 實作 get_config_schema 類方法
```python
@classmethod
def get_config_schema(cls) -> Dict[str, Dict[str, Any]]:
    """定義生成器的UI配置選項"""
    return {
        "type_ratio": {
            "type": "percentage_group",
            "label": "題型比例",
            "description": "調整整數基數與分數基數題型的出現頻率",
            "items": {
                "integer": {
                    "label": "整數底數（如 7^30）",
                    "default": 50
                },
                "fraction": {
                    "label": "分數底數（如 (3/5)^60）",
                    "default": 50
                }
            }
        }
    }
```

#### 2.3.2 驗證函數（遵循 RULES.config_schema）
```python
def _validate_config(self):
    """驗證配置完整性（內部使用）"""
    assert self.integer_weight + self.fraction_weight == 100, \
        f"百分比總和必須為100，當前={self.integer_weight + self.fraction_weight}"
    assert self.integer_weight > 0 and self.fraction_weight > 0, \
        "兩種題型百分比必須都>0"
```

**檢查點**: C101-C106

---

### 2.4 數學邏輯實作
**任務**: 實作核心數學邏輯（查表方案）

**步驟**:
1. 在 `__init__` 中調用 `_build_valid_combinations()`
2. 預篩選所有有效組合（基數 x 指數的組合）
3. 在 `_generate_core_question()` 中從清單隨機選取
4. 參考典範：`generators/algebra/double_radical_simplification.py` (L50-70)

**數學驗證重點**:
- 首數尾數分離正確性（正數/負數對數處理）
- 科學記號首位數字計算（$10^{\text{mantissa}}$ 反推）
- LaTeX 格式正確（分數符號、科學記號乘號）

**檢查點**: M201-M205

---

### 2.5 文檔撰寫
**任務**: 撰寫完整 Sphinx 文檔

**步驟**:
1. 模組級 docstring（檔案開頭，已完成）
2. 類別級 docstring（含 Args, Returns, Example，已完成）
3. 核心方法 docstring
   - `_build_valid_combinations()`: 說明預篩選邏輯
   - `_calculate_result()`: 說明首數尾數計算
   - `_format_explanation()`: 說明詳解格式

**檢查點**: 遵循 RULES.docstring_standard

---

## 3. 測試驗證計畫

### 3.1 基礎測試
```bash
# 測試 1: 導入測試
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; print('✅ 導入成功')"

# 測試 2: 實例化測試
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; gen = LargeExponentEstimationGenerator(); print('✅ 實例化成功')"

# 測試 3: 生成測試（整數題型）
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; gen = LargeExponentEstimationGenerator({'type_ratio': {'integer': 100, 'fraction': 0}}); q = gen.generate_question(); print('✅ 生成成功'); print('題目:', q['question'][:50])"

# 測試 4: 生成測試（分數題型）
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; gen = LargeExponentEstimationGenerator({'type_ratio': {'integer': 0, 'fraction': 100}}); q = gen.generate_question(); print('✅ 生成成功'); print('題目:', q['question'][:50])"

# 測試 5: 配置驗證
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; schema = LargeExponentEstimationGenerator.get_config_schema(); print('✅ 配置Schema正確'); print('配置項:', list(schema.keys()))"

# 測試 6: 驗證組合數量（應為 8*8 + 19*8 = 216）
py -c "from generators.exponential_logarithm.large_exponent_estimation import LargeExponentEstimationGenerator; gen = LargeExponentEstimationGenerator(); expected = 216; actual = len(gen.valid_combinations); print(f'✅ 預篩選組合數量: {actual} (預期: {expected}, {"通過" if actual == expected else "失敗"})')"
```

### 3.2 數學邏輯驗證測試
```python
# 建立獨立驗證腳本：tests/manual_verification.py
def verify_sample_1():
    """驗證樣本1數學邏輯"""
    import math
    log7 = 0.8451
    exp = 30
    total_log = exp * log7  # 25.353

    char = int(total_log)  # 25
    mant = total_log - char  # 0.353
    digit = 10 ** mant  # 約 2.25

    assert char == 25
    assert 2.2 <= digit <= 2.3
    print("✅ 樣本1驗證通過")

def verify_sample_4():
    """驗證樣本4負數尾數處理"""
    log3 = 0.4771
    log5 = 0.6990
    log_base = log3 - log5  # -0.2219
    exp = 60
    total_log = exp * log_base  # -13.314

    # 關鍵：負數尾數處理
    char = int(total_log) - 1  # -14
    mant = total_log - char  # 0.686
    digit = 10 ** mant  # 約 4.85

    assert char == -14
    assert 4.8 <= digit <= 4.9
    print("✅ 樣本4驗證通過")

if __name__ == "__main__":
    verify_sample_1()
    verify_sample_4()
```

### 3.3 檢查清單驗證

#### Phase 1: 需求分析
- [x] C001: 確認題目類型和數學邏輯（對數首數尾數估算）
- [x] C002: 確認是否需要圖形（否，純文字計算題）
- [x] C003: 確認是否需要配置（是，percentage_group）
- [x] C004: 選擇典範代碼參考（典範B）
- [x] C005: 確認數學邏輯策略（查表方案：預篩選有效組合）
- [x] C006: 確認元數據完整（指數對數/首數尾數應用/G11S1/WIDE）
- [x] C007: 樣本展示通過確認（5個樣本已提供）

#### Phase 2: 配置設計
- [ ] C101: `get_config_schema()` 定義正確
- [ ] C102: `percentage_group` 的 `items` 驗證
- [ ] C103: 百分比總和驗證（integer + fraction = 100）
- [ ] C104: 配置讀取正確（`type_ratio` 讀取邏輯）
- [ ] C105: 權重清單建立正確（`self.question_types`）

#### Phase 3: 核心邏輯
- [ ] C201: `_generate_core_question()` 實作完成
- [ ] C202: LaTeX 格式化正確
  - 科學記號：`$2.3 \times 10^{25}$`（使用 `\times`）
  - 分數：`$\frac{3}{5}$`
  - 對數：`$\log_{10}$`
- [ ] C203: 無 Unicode 數學符號（×, °, √ 等全部使用 LaTeX 命令）
- [ ] C204: `_get_fallback_question()` 實作完成
- [ ] C205: 返回結構完整（question, answer, explanation, metadata）

#### Phase 4: 數學邏輯
- [ ] M201: 預篩選邏輯正確（`_build_valid_combinations`）
- [ ] M202: 首數尾數分離正確（正數/負數情況）
- [ ] M203: 科學記號首位數字計算正確（$10^{\text{mantissa}}$）
- [ ] M204: 對數表使用正確（`STANDARD_LOG_VALUES`）
- [ ] M205: 邊界情況處理（負數尾數、極大指數）

#### Phase 5: 測試驗證
- [ ] T001: 生成器可獨立運作（導入+實例化+生成）
- [ ] T002: 配置系統正常（percentage_group 讀取）
- [ ] T003: 圖形正確生成（不適用）
- [ ] T004: LaTeX 編譯成功（5個樣本編譯測試）
- [ ] T005: 數學邏輯正確（手動驗證腳本通過）

#### 初始化檢查
- [ ] I001: `__init__.py` 遵循自動註冊模式
- [ ] I002: `__init__.py` 使用 `get_logger`
- [ ] I003: `__all__` 設為空列表

---

## 4. 時間估算

| 階段 | 預估時間 | 備註 |
|------|---------|------|
| 準備階段 | 2-3 分鐘 | 檢查/創建 logarithm 子包和 __init__.py |
| 生成器實作 | 15-20 分鐘 | 包含預篩選邏輯、首數尾數計算 |
| 配置系統 | 3-5 分鐘 | percentage_group 配置實作 |
| 數學邏輯 | 10-15 分鐘 | 查表方案較複雜（需處理正/負數尾數） |
| 文檔撰寫 | 3-5 分鐘 | Sphinx 格式完整文檔 |
| 測試驗證 | 5-8 分鐘 | 5類樣本驗證 + 數學邏輯驗證腳本 |
| **總計** | **40-55 分鐘** | 高於平均（25-40分鐘），因數學邏輯複雜 |

**時間超出原因**:
1. 對數表建立和驗證
2. 首數尾數分離邏輯（需處理負數情況）
3. 科學記號反推計算（$10^{\text{mantissa}}$）
4. 5類樣本的完整測試覆蓋

---

## 5. 風險評估

### 5.1 已識別風險

| 風險項 | 影響程度 | 緩解措施 |
|-------|---------|---------|
| **LaTeX 科學記號格式錯誤** | 高 | 遵循 `$m \times 10^{n}$` 標準格式，禁用 Unicode × 符號 |
| **對數表四捨五入誤差** | 中 | 固定使用 `STANDARD_LOG_VALUES` 常數表，保證一致性 |
| **首數查表反推不準確** | 中 | 使用 `round(digit, 1)` 統一四捨五入規則，±0.1 容錯 |
| **負數尾數處理錯誤** | 高 | 特別處理：`char = int(total_log) - 1`（當 total_log < 0 且非整數） |
| **分數基數為0或無效** | 低 | 在 `_build_valid_combinations` 階段預篩選，跳過無效分數對 |
| **極大指數計算溢出** | 低 | Python 浮點數精度足夠（指數範圍 20-100，log 值不超過 100） |
| **詳解換行符編譯失敗** | 中 | 使用 `\\\\\\\\` 雙重轉義確保 LaTeX 正確解析 |

### 5.2 回滾機制

如在任何階段遇到問題：

1. **Phase 2-3（配置/核心邏輯）錯誤**:
   - 記錄錯誤信息（檢查點ID、錯誤描述）
   - 評估是否為代碼問題或需求問題
   - 如為需求問題，回到 S2（需求確認）重新調整
   - 如為代碼問題，在 S3b 階段修正

2. **Phase 4（數學邏輯）驗證失敗**:
   - 執行手動驗證腳本（`tests/manual_verification.py`）
   - 對比樣本1-5的計算結果
   - 如計算邏輯錯誤，修正 `_calculate_result()`
   - 重新執行測試 T005

3. **Phase 5（測試）失敗**:
   - 如 T004（LaTeX 編譯）失敗：檢查格式化方法，修正 Unicode 符號
   - 如 T002（配置）失敗：檢查 percentage_group 讀取邏輯
   - 如 T001（基礎）失敗：檢查導入路徑和裝飾器註冊

---

## 6. LaTeX 格式規範（RULES.latex_boundary）

遵循指南第1369-1393行標準：

### 6.1 必須使用的 LaTeX 命令
```yaml
科學記號乘號:
  ❌ 錯誤: "$2.3 × 10^{25}$"  # Unicode ×
  ✅ 正確: "$2.3 \times 10^{25}$"

分數符號:
  ❌ 錯誤: "3/5"  # 純文字斜線
  ✅ 正確: "$\frac{3}{5}$"

對數符號:
  ❌ 錯誤: "$log_{10}$"  # 無反斜線
  ✅ 正確: "$\log_{10}$"

近似符號:
  ✅ 正確: "$\approx$"

括號（分數基數）:
  ✅ 正確: "$\left(\frac{3}{5}\right)^{60}$"  # 使用 \left \right 自動調整大小
```

### 6.2 詳解換行規範
```yaml
垂直間距:
  方案1: "$step1$ \\\\\\\\ $step2$"  # 雙重轉義的 \\
  方案2: 使用陣列環境（未採用，過於複雜）

當前選擇: 方案1（雙重轉義）
理由: 簡單直接，已在樣本中驗證通過
```

### 6.3 格式驗證函數
```python
def _validate_latex(self, latex_str: str) -> bool:
    """驗證 LaTeX 字串格式"""
    forbidden_unicode = ["×", "°", "√", "±", "≤", "≥"]

    for char in forbidden_unicode:
        if char in latex_str:
            self.logger.error(f"發現禁用的 Unicode 符號: {char}")
            return False

    return True
```

---

## 7. 完整檢查清單總覽

### Phase 1: 需求分析 ✅
- [x] C001-C007 (全部完成於計畫階段)

### Phase 2: 配置設計
- [ ] C101-C105 (待實作驗證)

### Phase 3: 核心邏輯
- [ ] C201-C205 (待實作驗證)

### Phase 4: 數學邏輯
- [ ] M201-M205 (待實作驗證)

### Phase 5: 測試驗證
- [ ] T001-T005 (待測試階段執行)

### 初始化檢查
- [ ] I001-I003 (待準備階段檢查)

**預期檢查點總數**: 25 個
**當前完成**: 7 個（Phase 1）
**待完成**: 18 個（Phase 2-5 + 初始化）

---

## 8. 審核確認

請審核以上計畫：

- [ ] **需求理解正確**: 對數首數尾數估算、科學記號答案、完整詳解
- [ ] **技術選型合理**: 典範B（預篩選查表）適合此題型
- [ ] **實作步驟清晰**: 從準備到測試的5個階段明確
- [ ] **時間估算可接受**: 40-55 分鐘（考慮數學邏輯複雜度）
- [ ] **風險評估完整**: 涵蓋 LaTeX 格式、數學計算、邊界情況
- [ ] **樣本覆蓋全面**: 5 類樣本（基礎、邊界最小/最大、負數尾數、首數邊界）

---

## 9. 執行授權確認

**計畫已完成，等待用戶審核。**

請確認：
- **A**: 計畫正確，開始執行開發
- **B**: 需要調整計畫（請說明調整內容）
- **C**: 保存計畫，稍後執行

---

**計畫作者**: Claude Sonnet
**生成時間**: 2025-10-17
**遵循指南**: AI開發指南 v4.6 混合優化版
**狀態流轉**: S0 → S0.5(計畫模式) → S1(典範B) → S2(批次確認) → S2.5(5樣本) → S3a(本計畫)
