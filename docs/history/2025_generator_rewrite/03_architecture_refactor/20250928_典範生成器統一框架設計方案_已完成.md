# 典範生成器統一框架設計方案

> **日期**: 2025-09-28
> **狀態**: 研擬中
> **目標**: 建立統一的生成器開發框架，讓工程師在框架內自由發揮而不會掉出舞台

## 🎯 核心問題

### **當前狀況：選擇困惑症**
從橫向比對四個典範生成器發現：
- **技術選擇自由度過高**：四種配置模式、四種重試策略、四種架構複雜度
- **缺乏決策指南**：新手不知道何時該用哪種技術選擇
- **檔案大小差異過大**：267行到653行，缺乏統一標準

### **核心風險：工程師容易掉出舞台**
1. **過度工程化**：看到複雜範例就模仿複雜架構
2. **技術選擇錯誤**：簡單需求用複雜技術，複雜需求用簡單技術
3. **維護困難**：風格不一致導致代碼難以維護

---

## 🏗️ 統一框架設計方案

### **設計原則：漸進式複雜度階梯**

#### **Level 1: 簡單生成器 (150-250行)**
**適用情況：**
- 參數 ≤ 3個
- 單一數學概念
- 無複雜邏輯分支

**技術選擇：**
```python
# 配置處理：基礎招式
self.param1 = options.get("param1", default_value)

# 重試機制：簡單版本
try:
    return self._generate_core_logic()
except Exception as e:
    self.logger.warning(f"生成失敗: {e}")
    return self._get_fallback_question()

# 核心邏輯：單一方法
def _generate_core_logic(self) -> Dict[str, Any]:
    # 直接實作，避免過度抽象
```

#### **Level 2: 標準生成器 (250-400行)**
**適用情況：**
- 參數 3-6個
- 多種題型模式
- 需要配置驗證

**技術選擇：**
```python
# 配置處理：中級招式
def _validate_config(self, options: Dict[str, Any]) -> None:
    # 集中驗證邏輯

# 重試機制：標準版本
def generate_question(self) -> Dict[str, Any]:
    for attempt in range(20):  # 統一重試次數
        try:
            result = self._generate_core_logic()
            if self._validate_result(result):
                return result
        except Exception as e:
            self.logger.warning(f"嘗試 {attempt + 1} 失敗: {e}")
    return self._get_fallback_question()

# 核心邏輯：分層抽象
def _generate_core_logic(self) -> Dict[str, Any]:
    mode = self._select_mode()
    return self._generate_by_mode(mode)
```

#### **Level 3: 複雜生成器 (400-500行)**
**適用情況：**
- 參數 > 6個
- 需要動態UI配置
- 複雜的數學邏輯

**技術選擇：**
```python
# 配置處理：華麗大招
@classmethod
def get_config_schema(cls) -> Dict[str, Any]:
    # 動態UI配置描述

# 重試機制：進階版本
# 查詢表系統：預計算優化
# 模版系統：複雜格式化
```

---

## 📋 統一標準規範

### **1. 檔案結構標準**
```python
"""模組docstring：必須包含功能描述、使用範例、技術特點"""

import 區塊
# 標準順序：標準庫 → 第三方庫 → 專案內部

@register_generator
class XxxGenerator(QuestionGenerator):
    """類別docstring：功能說明、參數描述、返回值格式、使用範例"""

    # 類別常數區塊（如有需要）
    CONSTANT_VALUES = {}

    def __init__(self, options: Dict[str, Any] = None):
        """統一的初始化模式"""

    def generate_question(self) -> Dict[str, Any]:
        """統一的生成邏輯模式"""

    def _generate_core_logic(self) -> Dict[str, Any]:
        """核心邏輯：私有方法命名統一"""

    def _get_fallback_question(self) -> Dict[str, Any]:
        """後備機制：統一命名"""

    # 基類方法實作區塊
    def get_grade(self) -> str:
    def get_category(self) -> str:
    # ... 其他基類方法
```

### **2. 配置處理決策樹**
```markdown
配置複雜度選擇指南：

參數數量 ≤ 3 且 邏輯簡單
└─> 基礎招式：options.get()

參數數量 3-6 或 需要驗證
└─> 中級招式：_validate_config() 方法

參數數量 > 6 或 需要動態UI
└─> 華麗大招：get_config_schema() + UI支援
```

### **3. 重試機制標準**
```python
# 統一重試次數標準
RETRY_ATTEMPTS = {
    "簡單生成器": 0,    # 直接try-catch
    "標準生成器": 20,   # 適中重試
    "複雜生成器": 50    # 較多重試（避免100次）
}

# 統一重試模版
def generate_question(self) -> Dict[str, Any]:
    max_attempts = self._get_max_attempts()  # 根據複雜度決定

    for attempt in range(max_attempts):
        try:
            result = self._generate_core_logic()
            if self._validate_result(result):
                self.logger.info(f"生成成功（第 {attempt + 1} 次嘗試）")
                return result
        except Exception as e:
            self.logger.warning(f"生成嘗試 {attempt + 1} 失敗: {str(e)}")

    self.logger.warning("達到最大嘗試次數，使用預設題目")
    return self._get_fallback_question()
```

### **4. 文檔標準規範**
```python
def method_name(self, param: type) -> type:
    """方法功能簡述

    詳細說明：說明方法的作用、數學原理（如適用）

    Args:
        param (type): 參數說明

    Returns:
        type: 返回值說明

    Example:
        >>> generator = XxxGenerator()
        >>> result = generator.method_name(value)
        >>> print(result)
        預期輸出

    Note:
        重要提醒或注意事項
    """
```

---

## 🎨 典範生成器模版系統

### **簡單生成器模版**
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""簡單數學題目生成器模版

適用於：參數≤3個、單一數學概念、無複雜邏輯分支的生成器。
使用基礎招式配置處理，避免過度工程化。

Example:
    >>> generator = SimpleGenerator()
    >>> question = generator.generate_question()
    >>> print(question['question'])
"""

from typing import Dict, Any, Optional
from utils import get_logger
from generators.base import QuestionGenerator, QuestionSize, register_generator

@register_generator
class SimpleGenerator(QuestionGenerator):
    """簡單題目生成器模版

    展示最基本的生成器實作模式，適合單一概念的數學題目。

    Args:
        options (Dict[str, Any], optional): 生成器配置選項
            param1 (type): 參數1說明，預設值
            param2 (type): 參數2說明，預設值

    Returns:
        Dict[str, Any]: 包含完整題目資訊的字典

    Example:
        >>> generator = SimpleGenerator()
        >>> question = generator.generate_question()
        >>> print(question['question'])
    """

    def __init__(self, options: Dict[str, Any] = None):
        """初始化簡單生成器"""
        super().__init__(options)
        self.logger = get_logger(self.__class__.__name__)

        # 基礎招式：options.get()配置處理
        options = options or {}
        self.param1 = options.get('param1', default_value)
        self.param2 = options.get('param2', default_value)

        self.logger.info("簡單生成器初始化完成")

    def generate_question(self) -> Dict[str, Any]:
        """生成題目的主要方法

        使用簡單的try-catch機制，適合邏輯單純的生成器。
        """
        self.logger.info("開始生成題目")

        try:
            return self._generate_core_logic()
        except Exception as e:
            self.logger.warning(f"生成失敗: {str(e)}")
            return self._get_fallback_question()

    def _generate_core_logic(self) -> Dict[str, Any]:
        """核心生成邏輯

        直接實作數學邏輯，避免過度抽象化。
        """
        # 實作核心數學邏輯
        question = "題目內容"
        answer = "答案內容"
        explanation = "解釋內容"

        return {
            "question": question,
            "answer": answer,
            "explanation": explanation,
            **self._get_standard_metadata()
        }

    def _get_fallback_question(self) -> Dict[str, Any]:
        """獲取預設題目"""
        return {
            "question": "預設題目",
            "answer": "預設答案",
            "explanation": "預設解釋",
            **self._get_standard_metadata()
        }

    # === 基類方法實作區塊 ===
    def get_grade(self) -> str:
        """獲取適用年級"""
        return "G10S1"

    def get_category(self) -> str:
        """獲取題目主類別"""
        return "主類別"

    def get_subcategory(self) -> str:
        """獲取題目子類別"""
        return "子類別"

    def get_subject(self) -> str:
        """獲取科目"""
        return "數學"

    def get_difficulty(self) -> str:
        """獲取難度等級"""
        return "EASY"  # 簡單生成器通常是基礎難度

    def get_question_size(self) -> int:
        """獲取題目顯示大小"""
        return QuestionSize.SMALL.value

    def get_figure_data_question(self) -> Optional[Dict[str, Any]]:
        """獲取題目圖形數據"""
        return None  # 簡單生成器通常無需圖形

    def get_figure_data_explanation(self) -> Optional[Dict[str, Any]]:
        """獲取解釋圖形數據"""
        return None

    def get_figure_position(self) -> str:
        """獲取題目圖形位置"""
        return "right"

    def get_explanation_figure_position(self) -> str:
        """獲取解釋圖形位置"""
        return "right"
```

---

## 🔧 實施計畫

### **Phase 1: 建立模版庫 (1小時)**
- 創建三個層級的生成器模版
- 建立配置決策指南文檔
- 制定文檔標準規範

### **Phase 2: 重構現有典範生成器 (2小時)**
- 按新標準重構四個典範生成器
- 統一重試機制和錯誤處理
- 標準化文檔格式

### **Phase 3: 驗證和文檔 (30分鐘)**
- 測試重構後的生成器
- 更新開發指南文檔
- 建立快速開始指南

---

## 🎯 預期效果

### **對新手工程師的好處**
1. **明確的技術選擇路徑**：不再困惑於該用哪種技術
2. **漸進式學習曲線**：從簡單到複雂的學習路徑
3. **複製友善的模版**：直接複製對應層級的模版開始開發

### **對專案維護的好處**
1. **統一的代碼風格**：減少維護成本
2. **可預測的架構**：容易理解和修改
3. **清晰的邊界**：知道何時該升級到更複雜的層級

### **對教師使用的好處**
1. **可預期的配置介面**：統一的配置體驗
2. **一致的文檔品質**：容易理解使用方法
3. **穩定的功能表現**：統一的錯誤處理和後備機制

---

## 📈 成功指標

- [ ] 新手工程師能在30分鐘內選擇合適的模版開始開發
- [ ] 所有生成器的文檔品質達到統一標準
- [ ] 代碼審查時不再出現架構選擇爭議
- [ ] 典範生成器成為真正可複製的開發範本

**結論：建立統一框架不是限制創意，而是提供穩固的舞台讓工程師安心發揮，不會掉出邊界。**