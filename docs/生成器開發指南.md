# 生成器開發指南

> **目標**: 讓工程師快速理解如何開發數學生成器
> **建立日期**: 2025-09-29
> **適用**: 數學測驗生成器專案

## 1. 開發流程

### 基本步驟
1. **建立生成器檔案**: 在 `generators/category/` 下建立 `.py` 檔案
2. **繼承基類**: 從 `QuestionGenerator` 繼承
3. **加上裝飾器**: 使用 `@register_generator` 自動註冊
4. **實作必要方法**: `_generate_core_question()` 和 `_get_fallback_question()` 抽象方法
5. **設定配置選項**: 實作 `get_config_schema()` 方法（可選）

### 最小可用骨架
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from typing import Dict, Any
from utils import get_logger
from ..base import QuestionGenerator, QuestionSize, register_generator

@register_generator
class YourGenerator(QuestionGenerator):

    def __init__(self, options=None):
        super().__init__(options)
        self.logger = get_logger(self.__class__.__name__)

    def _generate_core_question(self) -> Dict[str, Any]:
        """核心生成邏輯，實現具體的題目生成"""
        return {
            "question": "你的題目LaTeX",
            "answer": "答案LaTeX",
            "explanation": "解釋LaTeX",
            **self._get_standard_metadata()
        }

    def _get_fallback_question(self) -> Dict[str, Any]:
        """後備題目，當核心生成失敗時使用"""
        return {
            "question": "安全的預設題目LaTeX",
            "answer": "預設答案LaTeX",
            "explanation": "預設解釋LaTeX",
            **self._get_standard_metadata()
        }

    def get_question_size(self):
        return QuestionSize.MEDIUM

    def get_category(self):
        return "你的主類別"

    def get_subcategory(self):
        return "你的子類別"

    def get_grade(self):
        return "G10S1"  # 格式: G年級S學期
```

### 驗證生成器
執行 `python main.py` 確認：
- 生成器出現在UI的類別選單中
- 能正常生成題目
- 配置選項正常運作（如果有的話）

## 2. 新架構最佳實踐

### ✅ 必須遵循的標準

#### **Sphinx Docstring 標準**
所有類別、方法必須包含完整 docstring，使用 Google Style 格式：
```python
class YourGenerator(QuestionGenerator):
    """題目生成器簡短描述

    詳細說明生成器的功能和用途。

    Args:
        options (Dict[str, Any], optional): 生成器配置選項
            param1 (str): 參數1說明，預設"default"
            param2 (int): 參數2說明，預設10

    Returns:
        Dict[str, Any]: 包含完整題目資訊的字典

    Example:
        >>> generator = YourGenerator()
        >>> question = generator.generate_question()
        >>> print(question['question'])
        範例題目輸出
    """

    def generate_question(self) -> Dict[str, Any]:
        """生成一個完整的題目

        詳細說明生成邏輯和注意事項。

        Returns:
            Dict[str, Any]: 包含題目、答案、解釋等完整資訊

        Raises:
            ValueError: 當參數無效時拋出
        """
        pass
```

#### **統一 API 使用**
使用新架構的統一導入和數據類型：
```python
from utils import (
    get_logger, global_config,          # 核心工具
    Point, Triangle, distance,          # 幾何工具
    tikz_coordinate, ArcRenderer        # TikZ工具
)
from generators.base import QuestionGenerator, QuestionSize, register_generator

# 使用統一日誌器
self.logger = get_logger(self.__class__.__name__)

# 獲取全域設定
self.debug_mode = global_config.debug_mode
self.precision = global_config.tikz_precision
```

#### **數學精確性要求**
**使用 sympy 進行符號計算和 LaTeX 規範化**:
```python
from sympy import sqrt, pi, sin, cos, latex, simplify

def generate_question(self):
    # 使用 sympy 進行符號計算
    angle_rad = angle_deg * pi / 180
    result = simplify(sin(angle_rad))  # 符號運算，保持根式形式

    return {
        "question": f"$\\sin({angle_deg}^\\circ) = $",
        "answer": f"${latex(result)}$",  # 標準化的LaTeX輸出
        # ...
    }
```

#### **自動註冊機制**
使用標準的註冊模式：
```python
@register_generator  # 自動註冊裝飾器
class YourGenerator(QuestionGenerator):

    def get_category(self):
        return "數與式"  # 使用標準分類

    def get_subcategory(self):
        return "代數運算"
```

## 3. 題目取值方案設計 ⭐ 核心重點

> **重要理念**: 題目取值方案是生成器最核心的部分，要詳細思考和討論再決定
> **設計原則**: 多變但不複雜，不能讓學生沒辦法算，避免想當然的隨機出題

### 策略1: 答案逆推法（推薦用於複雜計算題）
**代表範例**: `DoubleRadicalSimplificationGenerator`
**核心思想**: 先決定好看的答案，再逆推到題目，過程保留所有數值

```python
# 實際代碼片段：雙重根號生成器
def _build_valid_combinations(self):
    """預篩選所有有效組合，確保答案漂亮"""
    from itertools import combinations

    self.valid_pairs = [
        (max(a, b), min(a, b))  # 確保 a >= b，使減法結果為正
        for a, b in combinations(range(1, self.max_value + 1), 2)
        if not self._is_perfect_square(a * b)  # 過濾完全平方數
    ]

def generate_question(self):
    # 從預篩選列表直接選擇，保證有效
    a, b = random.choice(self.valid_pairs)
    is_addition = random.choice([True, False])  # 隨機加減法

    # 使用答案逆推：(√a ± √b)² = a+b ± 2√(a×b)
    return self._generate_with_params(a, b, is_addition)
```
**優點**: 答案一定好看，學生有成就感，解題步驟清晰

### 策略2: 預建清單法（推薦用於概念理解題）
**代表範例**: `InverseTrigonometricFunctionGenerator`
**核心思想**: 預建特殊值清單，確保答案在學生掌握範圍內

```python
# 實際代碼片段：反三角函數生成器
def __init__(self, options=None):
    # 預建特殊角度清單，為學生好記憶
    self.special_angles = [
        -90, -60, -45, -30, 0, 30, 45, 60, 90,
        120, 135, 150, 180, 210, 225, 240, 270
    ]

def generate_question(self):
    # 從預建清單選取，保證學生能算出
    angle = random.choice(self.special_angles)

    if func_name == "tan" and angle in [90, 270]:
        continue  # 避免未定義值，除非是進階模式

    # 所有答案都是學生熟悉的標準值
    value = self._calculate_standard_value(func_name, angle)
```
**優點**: 答案標準化，符合教學進度，學生容易驗證

### 策略3: 限制隨機法（適用於基礎練習題）
**核心思想**: 在教學適宜的範圍內隨機，避免超出學生能力

```python
def generate_question(self):
    # 不是完全隨機，而是教學導向的限制隨機

    # ✅ 正確做法：限制在合理範圍
    numerator = random.randint(1, 12)    # 避免太大的數字
    denominator = random.randint(2, 8)   # 避免太複雜的分母

    # 確保結果是學生能處理的
    if numerator % denominator == 0:
        continue  # 避免整數答案，失去練習意義

    # ❌ 錯誤做法：想當然的隨機
    # numerator = random.randint(1, 1000)  # 太大，學生算不動
    # denominator = random.randint(1, 100) # 可能出現1，沒有意義
```


### 🎯 取值方案選擇指南

**選擇答案逆推法，當**：
- 計算過程複雜（如根式化簡、因式分解）
- 希望答案整潔漂亮
- 需要多步驟解題

**選擇預建清單法，當**：
- 答案有固定標準（如特殊角、常用公式）
- 重點是概念理解而非計算
- 需要與教學進度同步

**選擇限制隨機法，當**：
- 基礎練習需要大量變化
- 計算相對簡單
- 重點是熟練度而非技巧

**避免的陷阱**：
- ❌ 完全隨機出題，不考慮學生能力
- ❌ 答案過於複雜，打擊學習信心
- ❌ 沒有教學邏輯，純粹為了變化而變化

## 4. 抽象方法實作

### 必須實作的方法

#### `get_question_size()`: 題目顯示大小
回傳 `QuestionSize` 枚舉值，可用選項：
- `QuestionSize.SMALL` (1) - 1x1，適合簡單計算題
- `QuestionSize.WIDE` (2) - 2x1，適合較長題目
- `QuestionSize.SQUARE` (3) - 1x2，適合有圖形的題目
- `QuestionSize.MEDIUM` (4) - 2x2，適合中等複雜度
- `QuestionSize.LARGE` (5) - 3x2，適合複雜題目
- `QuestionSize.EXTRA` (6) - 4x2，適合最複雜的題目

#### `get_category()`: 題目主類別
為保持UI顯示的一致性，建議從以下標準分類中選擇：

**高一上**:
- "數與式" - 數與代數運算
- "指數與對數" - 指數與對數函數
- "多項式函數" - 多項式相關題型
- "直線與圓" - 解析幾何

**高一下**:
- "數列與級數" - 數列級數計算
- "數據分析" - 統計與數據處理
- "排列組合" - 排列組合計算
- "機率" - 機率計算

**高二上**:
- "三角函數" - 三角函數圖形與性質
- "平面向量" - 二維向量運算

**高二下**:
- "空間向量" - 三維向量運算
- "空間中的平面與直線" - 立體幾何
- "矩陣" - 矩陣運算

**高三上**:
- "極限" - 極限概念
- "微分" - 微分計算
- "積分" - 積分計算

**高三下**:
- "二次曲線" - 圓錐曲線
- "複數" - 複數運算
- "統計機率" - 進階統計

#### `get_subcategory()`: 題目子類別
具體的題型分類，如："三角函數值計算"、"雙重根式化簡"

#### `get_grade()`: 年級格式
格式：`G年級S學期`，如 "G10S1"（高一上）、"G11S2"（高二下）
根據分類給出年級建議，但依實際情況決定

### 可選重寫的方法
- `get_subject()`: 回傳科目名稱，預設"數學"
- `get_difficulty()`: 回傳難度等級，預設"MEDIUM"
- `get_figure_position()`: 回傳題目圖形位置，預設 `"right"`
  - 有效值: `"right"` (預設), `"left"`, `"bottom"`, `"none"`
  - 注意: 若 `get_figure_data_question()` 返回 `None`，系統自動忽略此設定
- `get_explanation_figure_position()`: 回傳解釋圖形位置，預設 `"right"`
  - 有效值: `"right"` (預設), `"bottom"`, `"none"`
  - ⚠️ 不支援 `"left"` 選項（與題目圖形不同）
  - 注意: 若 `get_figure_data_explanation()` 返回 `None`，系統自動忽略此設定

### 已實現的實用方法
- `generate_batch(count)`: 批量生成指定數量的題目
- `set_options(options)`: 動態設置生成器選項
- `has_config()`: 自動檢查生成器是否需要配置（根據 get_config_schema()）

### 標準元數據使用
使用 `self._get_standard_metadata()` 自動產生完整元數據

## 5. 配置系統整合

### 支援的控件類型

系統目前支援 4 種配置控件類型（基於 ConfigFactory 實際實現）：

#### **1. select - 下拉選擇框**
```python
"function_scope": {
    "type": "select",
    "label": "函數範圍",
    "default": "basic",
    "options": ["basic", "extended"]
}
```

#### **2. checkbox - 勾選框**
```python
"allow_negative": {
    "type": "checkbox",
    "label": "允許負數",
    "default": False
}
```

#### **3. number_input - 數字輸入框**
```python
"max_value": {
    "type": "number_input",
    "label": "數值上限",
    "default": 25,
    "min": 5,
    "max": 100
}
```

#### **4. percentage_group - 百分比分配**
```python
"mode_weights": {
    "type": "percentage_group",
    "label": "題型比例分配",
    "items": {
        "original": {"label": "0~90°轉換", "default": 70},
        "formula": {"label": "公式問答", "default": 10},
        "narrow_angle": {"label": "銳角計算", "default": 20}
    }
}
```

### 實際生成器配置範例

#### **簡單配置：雙重根號生成器**
```python
@classmethod
def get_config_schema(cls) -> Dict[str, Dict[str, Any]]:
    return {
        "max_value": {
            "type": "number_input",
            "label": "數值上限",
            "default": 25,
            "min": 5,
            "max": 100,
            "description": "控制生成答案數字的最大值"
        }
    }

def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    options = options or {}

    # 簡潔的配置處理
    self.max_value = options.get('max_value', 25)

    # 建立預篩選組合，避免生成時重複計算
    self._build_valid_combinations()
```

#### **複雜配置：三角函數生成器**
```python
@classmethod
def get_config_schema(cls) -> Dict[str, Dict[str, Any]]:
    return {
        "function_scope": {
            "type": "select",
            "label": "函數範圍",
            "default": "basic",
            "options": ["basic", "extended"]
        },
        "angle_mode": {
            "type": "select",
            "label": "角度模式",
            "default": "degree",
            "options": ["degree", "radian", "mixed"]
        }
    }

def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    config = options or {}

    # 基本配置讀取
    function_scope = config.get("function_scope", "basic")
    if function_scope == "extended":
        self.functions = ["sin", "cos", "tan", "csc", "sec", "cot"]
    else:
        self.functions = ["sin", "cos", "tan"]

    self.angle_mode = config.get("angle_mode", "degree")
```

#### **百分比配置：角度轉換生成器**
```python
@classmethod
def get_config_schema(cls):
    return {
        "mode_weights": {
            "type": "percentage_group",
            "label": "題型比例分配",
            "description": "調整三種題型的出現頻率，總和自動保持為100%",
            "items": {
                "original": {"label": "0~90°轉換", "default": 70},
                "formula": {"label": "公式問答", "default": 10},
                "narrow_angle": {"label": "銳角計算", "default": 20}
            }
        }
    }

def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    options = options or {}

    # percentage_group 在 ConfigFactory.create_percentage_group() 已強制驗證總和=100%
    # 生成器層面無需重複驗證，直接使用即可（遵循單一職責原則）
    mode_config = options.get("mode_weights", {})
    if mode_config:
        self.mode_weights = [
            mode_config.get("original", 70),
            mode_config.get("formula", 10),
            mode_config.get("narrow_angle", 20)
        ]
    else:
        self.mode_weights = [70, 10, 20]  # 預設值
```

#### **為什麼生成器不驗證 percentage_group？**
- **單一職責原則**: UI層（ConfigFactory）負責所有輸入驗證
- **信任邊界**: 生成器信任從UI傳入的配置已經驗證完成
- **避免重複驗證**: 減少代碼冗餘，提升維護性
- **架構分層**: UI層=輸入驗證，生成器層=業務邏輯

### 配置最佳實踐

#### **簡潔的配置處理**

**設計原則**: 信任 UI 層驗證，生成器專注業務邏輯

**推薦做法**:
```python
def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    options = options or {}

    # ✅ 簡潔直接：從 options 讀取並設定預設值
    self.max_value = options.get('max_value', 25)
    self.difficulty = options.get('difficulty', 'MEDIUM')
```

**避免過度工程化**:
```python
# ❌ 不推薦：生成器內重複驗證
if not isinstance(options.get('max_value'), int):
    raise ValueError("max_value 必須是整數")

# ❌ 不推薦：複雜的 Pydantic 模型（適合複雜系統，但生成器不需要）
class GeneratorConfig(BaseModel):
    max_value: int = Field(ge=1, le=100)
    difficulty: str = Field(regex="^(EASY|MEDIUM|HARD)$")
```

**為什麼簡潔就好？**
1. **UI 層已驗證**: ConfigFactory 確保所有輸入合法（類型、範圍、總和）
2. **避免重複**: 兩層驗證造成維護負擔和邏輯衝突
3. **教師友善**: 代碼簡單易讀，降低維護門檻
4. **遵循 CLAUDE.md 原則**: 該用基礎招式就用基礎招式，不過度設計

**例外情況**:
如果生成器有複雜的內部狀態依賴或需要轉換配置格式，可以適度增加邏輯：
```python
# 配置轉換範例（合理的複雜度）
function_scope = options.get("function_scope", "basic")
if function_scope == "extended":
    self.functions = ["sin", "cos", "tan", "csc", "sec", "cot"]
else:
    self.functions = ["sin", "cos", "tan"]
```

#### **合理的預設值**
- 所有配置項都要有合理的預設值
- 預設值要讓生成器在無配置時也能正常運作
- percentage_group 的預設值總和必須等於 100

詳細配置選項請參閱：[配置控件擴展指南.md](配置控件擴展指南.md)

**如果需要自行開發新的配置控件類型**，請參閱該指南進行擴展。有了新的配置選項，也必須回來更新本開發指南。

## 6. 圖形數據整合

### 可用的圖形類型
系統提供了以下基礎圖形類型：
1. **`unit_circle`** - 單位圓，包含角度、點等
2. **`circle`** - 一般圓形
3. **`coordinate_system`** - 坐標系
4. **`point`** - 點
5. **`line`** - 線段
6. **`angle`** - 角度
7. **`label`** - 文字標籤

預定義複合圖形類型：
1. **`standard_unit_circle`** - 標準單位圓，包含坐標軸、圓、點、角度等

### 圖形整合方法
**如果生成器需要附圖，必須實作**:
- `get_figure_data_question()`: 回傳題目圖形配置或 None
- `get_figure_data_explanation()`: 回傳解釋圖形配置或 None

### 圖形方法實作範例
```python
def get_figure_data_question(self):
    """回傳題目圖形配置"""
    return {
        'type': 'standard_unit_circle',
        'params': {
            'angle': 30,  # 實際參數
            'show_coordinates': True,
            'show_angle': True,
            'highlight_function': 'sin'
        },
        'options': {'scale': 1.0}
    }

def get_figure_data_explanation(self):
    """回傳解釋圖形配置"""
    # 通常比題目圖形包含更多資訊
    return {
        'type': 'standard_unit_circle',
        'params': {
            'variant': 'explanation',  # 解釋模式
            'angle': 30,
            'show_coordinates': True,
            'show_angle': True,
            'show_point': True,
            'show_radius': True,
            'highlight_function': 'sin'
        },
        'options': {'scale': 1.2}  # 解釋圖稍大
    }
```

### 圖形位置配置

#### 題目圖形位置 (`figure_position`)
- **`"right"`** (預設): 圖在右側 (40% 寬度)，文字在左側 (60% 寬度)
- **`"left"`**: 圖在左側，文字在右側
- **`"bottom"`**: 圖在文字下方，使用全寬
- **`"none"`**: 無圖形，文字使用全寬

#### 解釋圖形位置 (`explanation_figure_position`)
- **`"right"`** (預設): 圖在右側 minipage (38% 寬度)，文字在左側 (58% 寬度)
- **`"bottom"`**: 圖在文字下方，使用全寬
- **`"none"`**: 無圖形，文字使用全寬
- ⚠️ **不支援 `"left"` 選項**（與題目圖形不同）

#### 圖形位置與顯示邏輯

**重要**: 圖形位置參數僅在對應的 `get_figure_data_*()` 方法返回有效圖形數據時生效。

**典型使用情境**：
```python
# 情境1: 有圖的生成器（使用預設 "right"）
def get_figure_data_question(self):
    return {'type': 'unit_circle', 'params': {'angle': 30}}
# → 圖形顯示在右側 (40% 寬)，文字在左側 (60% 寬)

# 情境2: 無圖的生成器（無需重寫 get_figure_position）
# get_figure_data_question() 繼承基類返回 None
# → 系統自動全寬顯示文字，忽略 figure_position 設定

# 情境3: 特殊排版需求（需要大圖時）
def get_figure_position(self):
    return "bottom"  # 圖形使用全寬顯示
```

詳細圖形開發請參閱：[圖形生成器開發指南.md](圖形生成器開發指南.md)
可用圖形列表在： [available_figures.md](available_figures.md)

**如果需要開發新的圖形類型**，請參閱圖形開發指南進行擴展。有了新的圖形類型，也必須回來更新本開發指南的可用圖形類型列表。

## 7. 確定性生成設計與穩定性保證

### 現代生成器設計理念

**核心原則**: 通過預篩選和確定性設計，從源頭避免錯誤，而非依賴重試機制。

**設計哲學**:
- ❌ **傳統做法**: 隨機生成 → 檢查有效性 → 失敗重試 → 達到上限返回錯誤
- ✅ **現代做法**: 預先篩選有效組合 → 確定性選擇 → 保證每次成功

**優勢**:
1. **性能**: 消除重試循環，生成速度穩定
2. **可預測性**: 不會因為運氣不好而失敗
3. **教學友善**: 保證題目品質一致
4. **代碼簡潔**: 減少複雜的錯誤處理邏輯

### 確定性生成模式
**現代生成器採用確定性設計，杜絕重試機制**:
```python
def _generate_core_question(self) -> Dict[str, Any]:
    """核心生成邏輯 - 確定性設計避免失敗"""
    # 1. 從預篩選有效組合中確定性選擇
    combination = random.choice(self.valid_combinations)

    # 2. 使用簡單邏輯生成題目，避免複雜判斷
    question_latex = f"${self._format_expression(combination)}$"
    answer_latex = f"${self._calculate_answer(combination)}$"

    return {
        "question": question_latex,
        "answer": answer_latex,
        "explanation": self._generate_explanation(combination),
        **self._get_standard_metadata()
    }

def _get_fallback_question(self) -> Dict[str, Any]:
    """後備題目 - 當核心生成失敗時的安全機制"""
    return {
        "question": "$\\sqrt{2} + \\sqrt{3} = $",  # 固定的安全題目
        "answer": "$\\sqrt{2} + \\sqrt{3}$",
        "explanation": "此為最簡根式，無法進一步化簡",
        **self._get_standard_metadata()
    }
```

### 預篩選策略實現
**建構有效組合列表避免生成時失敗**:
```python
def __init__(self, options: Dict[str, Any] = None):
    super().__init__(options)
    # 初始化時建構所有有效組合
    self._build_valid_combinations()

def _build_valid_combinations(self):
    """預篩選有效的參數組合，確保每次生成都成功"""
    from itertools import combinations  # 導入組合工具

    self.valid_combinations = []

    # 根據數學邏輯預篩選有效組合
    for a, b in combinations(range(1, self.max_value + 1), 2):
        if self._is_valid_combination(a, b):
            self.valid_combinations.append((max(a, b), min(a, b)))

    self.logger.info(f"預篩選完成，有效組合數量: {len(self.valid_combinations)}")

def _is_valid_combination(self, a: int, b: int) -> bool:
    """數學邏輯驗證，例如確保不是完全平方數"""
    return not self._is_perfect_square(a * b)
```

### 模板系統組織
**必須使用類內常量組織**:
```python
class YourGenerator(QuestionGenerator):
    # 模板集中管理
    EXPLANATION_TEMPLATES = {
        "type_a": "模板內容 {param1} 和 {param2}",
        "type_b": "另一種模板 {param1} 的處理方式",
    }

    def _generate_explanation(self, question_type, param1, param2):
        # 模板選擇邏輯
        template = self.EXPLANATION_TEMPLATES[question_type]
        return template.format(param1=param1, param2=param2)
```

## 8. 需求導向選擇

根據你的開發需求，選擇合適的參考範例：

### 我要固定概念記憶題目
**參考**: `InverseTrigonometricFunctionGenerator`
- 預建特殊角度清單，教學重點明確
- 簡單的 `options.get()` 參數處理
- 無需動態配置UI，專注教學邏輯

**適用場景**: 特殊角度、公式記憶、基礎概念練習

### 我要數值計算可調題目
**參考**: `DoubleRadicalSimplificationGenerator`
- 完整LaTeX模板系統，專業顯示
- 預篩選284個有效組合，確保數學有效性
- number_input配置控件，教師可調整數值範圍

**適用場景**: 代數計算、可變難度、參數化數學題

### 我要多題型權重配置
**參考**: `TrigAngleConversionGenerator`
- percentage_group配置控件，視覺化比例調整
- 三種題型動態權重分配（第一象限轉換、公式問答、窄角轉換）
- 現代化配置UI整合

**適用場景**: 綜合練習、多元題型混合、比例化教學

### 我要複雜推理步驟題目
**參考**: `TrigonometricFunctionGenerator`
- 完整EXPLANATION_TEMPLATES模板系統
- 預篩選49個有效角度-函數組合
- 多象限角度處理與詳細解析步驟

**適用場景**: 推理訓練、詳細教學解析、三角函數深度學習

## 9. 問題排查

### 生成器沒出現在UI
**檢查清單**:
1. ✅ 是否有 `@register_generator` 裝飾器
2. ✅ 檔案是否在正確的 `generators/category/` 路徑
3. ✅ 是否有語法錯誤導致導入失敗
4. ✅ `get_category()` 和 `get_subcategory()` 回傳值是否正確

**偵錯方法**:
```bash
# 檢查生成器導入和註冊狀態
py -c "
from generators.your_category.your_generator import YourGenerator
from utils.core.registry import registry
print('✅ 導入成功')
print('註冊生成器列表:')
for (category, subcategory), generator_class in registry.get_all_generators().items():
    print(f'- {generator_class.__name__} [{category}/{subcategory}]')
"

# 檢查自動註冊系統日誌
py -c "
import logging
logging.basicConfig(level=logging.INFO)
from generators import *  # 觸發自動註冊
"
```

### 配置選項不生效
**常見原因**:
- `get_config_schema()` 格式錯誤
- 在 `__init__()` 中忘記讀取 `options` 參數
- JSON Schema 格式不符合規範

**驗證方法**:
```python
# 檢查 schema 格式
generator = YourGenerator()
print(generator.get_config_schema())

# 檢查選項讀取
generator = YourGenerator({'your_option': 'test_value'})
print(generator.your_option)  # 應該印出 'test_value'
```

### LaTeX 顯示錯誤
**常見問題**: 使用Unicode符號導致PDF顯示異常

**正確做法**:
```python
# ✅ 使用LaTeX命令
degree = f"${angle}^\\circ$"        # 度數符號
times = f"$a \\times b$"            # 乘號
sin_func = f"$\\sin({angle})$"      # 三角函數

# ❌ 避免Unicode
degree = f"${angle}°$"              # 會在PDF中顯示錯誤
times = f"$a × b$"                  # 會在PDF中顯示錯誤
```

### 題目邏輯錯誤
**數學驗證方法**:
1. 手動計算幾個範例確認答案正確
2. 檢查定義域/值域限制
3. 驗證特殊值的處理
4. 確認邊界條件

**新架構錯誤處理驗證**:
```python
def test_generator_new_architecture():
    generator = YourGenerator()

    # 測試新架構方法存在
    assert hasattr(generator, '_generate_core_question')
    assert hasattr(generator, '_get_fallback_question')

    # 測試標準生成方法
    for _ in range(10):
        question = generator.generate_question()  # 使用基類的統一錯誤處理
        assert 'question' in question
        assert 'answer' in question
        assert 'explanation' in question

    # 測試後備機制
    fallback = generator._get_fallback_question()
    assert fallback['question'] is not None
    assert fallback['answer'] is not None

    # 測試預篩選機制（如適用）
    if hasattr(generator, 'valid_combinations'):
        assert len(generator.valid_combinations) > 0
        print(f"✅ 預篩選組合數量: {len(generator.valid_combinations)}")
```

---

## 參考資源

**詳細實施指南**:
- [配置控件擴展指南.md](配置控件擴展指南.md) - 配置UI實現
- [圖形生成器開發指南.md](圖形生成器開發指南.md) - 圖形整合專門指南
- [available_figures.md](available_figures.md) - 可用圖形清單
- [代碼註解規範.md](代碼註解規範.md) - 註解撰寫標準
- [生成器檔案結構規範.md](生成器檔案結構規範.md) - 代碼結構標準

**典範生成器範例**:
- `generators/trigonometry/InverseTrigonometricFunctionGenerator.py`
- `generators/algebra/double_radical_simplification.py`
- `generators/trigonometry/TrigAngleConversionGenerator.py`
- `generators/trigonometry/TrigonometricFunctionGenerator.py`

---

**撰寫日期**: 2025-09-29
**版本**: 2.0
**狀態**: 結構優化完成