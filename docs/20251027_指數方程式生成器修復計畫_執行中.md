# ExponentialEquationGenerator 修復與擴充計畫

> **建立時間**: 2025-10-27
> **狀態**: 執行中
> **預估總時間**: 70分鐘
> **負責人**: Claude Code

---

## 📋 執行摘要

針對 Gemini 生成的 `ExponentialEquationGenerator.py` 進行審查後，發現 2 個影響正確性的 bug、1 個功能缺失、2 個品質優化項目。本計畫將逐一修復並驗證。

---

## 🎯 問題清單

### 高優先級（影響正確性）

#### 問題1：題型三答案重複 ⚠️

**問題描述**:
```python
# 當前輸出
答案: $x = 1$ 或 $x = 1$  # 重複
```

**根本原因**:
- 兩個因式可能產生相同的解
- 答案列表未去重

**修復位置**: `_generate_type3()` line 486-495

**修復方案**:
```python
# 修復前
solutions = [factor1.solution(), factor2.solution()]
solutions = [s for s in solutions if s is not None]

# 修復後
solutions = [factor1.solution(), factor2.solution()]
solutions = [s for s in solutions if s is not None]
solutions = list(set(solutions))  # 去重
solutions.sort()  # 排序
```

**驗證方式**:
- 生成 10 組題型三題目
- 檢查答案中無重複值

---

#### 問題2：題型二詳解邏輯錯誤 ⚠️⚠️

**問題描述**:
```python
# 錯誤案例
Factor1: base=2, target=8 → 解 x=3
Factor2: base=2, target=2 → 解 x=1
solutions 排序後: [1, 3]

# 當前輸出（錯誤）
$2^x = 8 \Rightarrow x = 1$  # 錯誤對應
$2^x = 2 \Rightarrow x = 3$  # 錯誤對應
```

**根本原因**:
- 代碼假設 `solutions[0]` 對應 `k1`，`solutions[1]` 對應 `k2`
- 但 solutions 會被排序，破壞對應關係

**修復位置**: `_generate_type2_explanation()` line 686-687

**修復方案**:
```python
# 建立正確的映射關係
solution_map = {}
if factor1.has_real_solution():
    sol1 = factor1.solution()
    if sol1 is not None:
        solution_map[sol1] = k1

if factor2.has_real_solution():
    sol2 = factor2.solution()
    if sol2 is not None:
        solution_map[sol2] = k2

# 使用映射生成詳解
for sol in solutions:
    target = solution_map[sol]
    steps.append(f"${base}^x = {self._format_fraction(target)} \\Rightarrow x = {self._format_fraction(sol)}$")
```

**驗證方式**:
- 生成 10 組題型二題目
- 手動驗證詳解中的 base^x = target 與解的對應正確性

---

### 中優先級（功能擴充）

#### 問題3：題型一鏈式求解未實現 📦

**問題描述**:
- 文檔範例 1.2 承諾的功能未實現
- 題型一變化度較低

**預期功能**:
```
題目：
已知 $2^x = 8$，求 $81^y = 27^x$ 中的 $y$ 值。

詳解：
1. 從 $2^x = 8$ 開始：$x = 3$
2. 代入第二式：$81^y = 27^3$
3. $(3^4)^y = (3^3)^3 \Rightarrow 3^{4y} = 3^9$
4. 比較指數：$4y = 9 \Rightarrow y = \frac{9}{4}$
```

**實現位置**: 新增 `_generate_type1_chain()` 方法

**實現方案**:
```python
def _generate_type1_chain(self) -> Dict[str, Any]:
    """生成鏈式求解題型

    關係一：base1^x = value （保證 x 為簡單整數）
    關係二：base2^y = base3^x （需要代入 x 求 y）
    """
    # Step 1: 生成關係一
    base1 = random.choice([2, 3, 5])
    x_solution = random.choice([1, 2, 3])
    value = base1 ** x_solution

    # Step 2: 生成關係二
    base2 = random.choice([b for b in [2, 3, 5] if b != base1])
    base3 = random.choice([2, 3, 5])

    p = random.choice([2, 3, 4])  # base2 = common^p
    q = random.choice([2, 3, 4])  # base3 = common^q

    left_base = base2 ** p
    right_base = base3 ** q

    # Step 3: 計算 y
    # py = qx → y = qx/p
    y_solution = Fraction(q * x_solution, p)

    # Step 4: 構建題目和詳解
    question = f"已知 ${base1}^x = {value}$，求 ${left_base}^y = {right_base}^x$ 中的 $y$ 值。"
    answer = f"$x = {x_solution}, y = {self._format_fraction(y_solution)}$"

    # 詳解生成（4步驟）
    explanation = self._generate_type1_chain_explanation(
        base1, value, x_solution,
        left_base, right_base, base2, base3, p, q, y_solution
    )

    return {...}
```

**整合方式**:
```python
def _generate_type1(self):
    """修改現有方法支援鏈式變體"""
    use_chain = random.choice([True, False])  # 50% 機率

    if use_chain:
        return self._generate_type1_chain()
    else:
        return self._generate_type1_basic()  # 現有邏輯重命名
```

**驗證方式**:
- 生成 5 組鏈式題目
- 手動驗證解的正確性
- 確認詳解步驟完整

---

### 低優先級（品質優化）

#### 問題4：詳解格式不規範 📝

**問題描述**:
```latex
# 當前格式（不規範）
$比較指數：4x+10 = x+4$

# 正確格式
比較指數：$4x+10 = x+4$
```

**影響**: LaTeX 規範性問題，通常不影響 PDF 顯示

**修復位置**:
- `_generate_type1_explanation()` line 635
- 其他詳解方法中的類似問題

**修復方案**:
- 將中文文字移出數學模式 `$...$`
- 統一格式：`中文說明：$數學式$`

---

#### 問題5：題型二進階隱藏未實現 🎨

**問題描述**:
- 代碼 line 370-381 宣告了隱藏邏輯但未實現
- 註解說「為了簡化使用基本形式」

**預期功能**:
```
基本形式：  2^(2x) - 10·2^x + 16 = 0
進階隱藏：  4^x - 5·2^(x+1) + 16 = 0  ← 需要實現
```

**實現位置**: `_generate_type2()` line 370-381

**實現方案**:
```python
def _apply_type2_advanced_hiding(self, base, coeff_y2, coeff_y1, coeff_y0):
    """應用進階隱藏變形

    轉換規則：
    1. base^(2x) → (base^2)^x
    2. coeff_y1 · base^x → (coeff_y1/base) · base^(x+1)

    Example:
        2^(2x) - 10·2^x + 16 = 0
        → 4^x - 5·2^(x+1) + 16 = 0
    """
    # 檢查係數是否可被 base 整除（確保變形合理）
    if coeff_y1 % base != 0:
        return None  # 無法變形，返回 None

    new_base = base ** 2
    new_coeff = coeff_y1 // base

    # 構建隱藏後的方程式
    terms = []
    terms.append(f"{new_base}^x")

    if new_coeff > 0:
        terms.append(f"- {abs(new_coeff)} \\cdot {base}^{{x+1}}")
    else:
        terms.append(f"+ {abs(new_coeff)} \\cdot {base}^{{x+1}}")

    if coeff_y0 > 0:
        terms.append(f"+ {self._format_fraction(coeff_y0)}")
    else:
        terms.append(f"- {self._format_fraction(abs(coeff_y0))}")

    return " ".join(terms) + " = 0"
```

**驗證方式**:
- 生成 10 組題型二題目
- 確認約 50% 使用進階隱藏
- 手動驗證隱藏變形的數學正確性

---

## 🔄 執行順序

按優先級和依賴關係排序：

1. **問題2** - 題型二詳解邏輯錯誤（15分鐘）
2. **問題1** - 題型三答案重複（5分鐘）
3. **問題3** - 題型一鏈式求解（20分鐘）
4. **問題5** - 題型二進階隱藏（20分鐘）
5. **問題4** - 詳解格式優化（10分鐘）

**總計**: 70分鐘

---

## ✅ 驗證檢查清單

### 問題1驗證
- [ ] 生成 10 組題型三題目
- [ ] 確認無重複答案
- [ ] 答案已排序

### 問題2驗證
- [ ] 生成 10 組題型二題目
- [ ] 手動檢查詳解對應正確
- [ ] 測試邊界情況（k1=k2）

### 問題3驗證
- [ ] 生成 5 組鏈式題目
- [ ] 手動驗證 x, y 解正確
- [ ] 確認詳解完整
- [ ] 檢查基本題型未受影響

### 問題5驗證
- [ ] 生成 10 組題型二題目
- [ ] 確認隱藏比例約 50%
- [ ] 手動驗證變形正確
- [ ] 確認基本形式未受影響

### 問題4驗證
- [ ] 檢視所有詳解方法
- [ ] 確認中文在數學模式外
- [ ] LaTeX 編譯無警告

---

## 📊 完成標準

1. **所有修復通過驗證檢查清單**
2. **生成 30 組測試題目（每種題型 10 組）無錯誤**
3. **代碼審查無新增問題**
4. **文檔更新（如有新功能）**

---

## 🚨 風險評估

| 風險 | 可能性 | 影響 | 應對策略 |
|------|--------|------|---------|
| 問題2修復破壞現有邏輯 | 低 | 高 | 充分測試，保留回滾點 |
| 問題3鏈式求解複雜度超預期 | 中 | 中 | 簡化設計，先實現基本版 |
| 問題5隱藏變形係數不合理 | 中 | 低 | 添加驗證邏輯，不合理時回退基本形式 |
| 格式修復引入 LaTeX 錯誤 | 低 | 低 | 測試 PDF 生成 |

---

## 📝 備註

- Gemini 生成的代碼整體品質優秀（8.5/10）
- 核心架構無需調整
- 修復後預期達到 9.5/10

**狀態**: 待用戶授權開始執行
