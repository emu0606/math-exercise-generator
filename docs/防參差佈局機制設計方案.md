# 防參差佈局機制設計方案

> **文檔版本**: v1.0  
> **建立時間**: 2025-09-13  
> **目標**: 設計實現"高度2的格子不會混入高度1的行內"的佈局機制

## 🎯 **設計目標**

### **核心需求**
實現同一行內所有題目必須有相同高度，避免視覺參差狀態。

### **預期效果**
```
✅ 理想狀態：
     列0  列1  列2  列3
行0  [S1] [S2] [S3] [ ]   ← 純height=1
行1  [Q1] [ ]  [ ]  [ ]   ← Q1上半部分(height=2)
行2  [Q1] [ ]  [ ]  [ ]   ← Q1下半部分

❌ 避免狀態：
     列0  列1  列2  列3  
行0  [S1] [Q1] [S2] [ ]   ← 混合height=1和height=2
行1  [ ]  [Q1] [ ]  [ ]   ← 參差不齊
```

---

## 📋 **方案對比分析**

### **方案A：行高度鎖定機制**

#### **核心邏輯**
- 一旦某行被height=X的題目佔用，該行就"鎖定"為height=X
- 後續只有height=X的題目可以放入該行的空位
- 不同高度的題目被強制分配到不同行

#### **實例分析1**: 2個SMALL(1x1) + 1個SQUARE(1x2)

**處理流程**：
```
題目順序: [SMALL1, SMALL2, SQUARE1]

處理SMALL1:
- 嘗試行0 → 空行，可放置 → 放置(行0,列0)
- 行0鎖定為height=1

處理SMALL2:  
- 嘗試行0 → height=1，匹配 → 放置(行0,列1)
- 行0維持height=1鎖定

處理SQUARE1:
- 嘗試行0 → height=1，但需要height=2 → 衝突，拒絕
- 嘗試行1 → 空行，可放置 → 放置(行1,列0)
- 行1鎖定為height=2

最終結果:
     列0  列1  列2  列3
行0  [S1] [S2] [ ]  [ ]   ← 鎖定height=1
行1  [Q1] [ ]  [ ]  [ ]   ← 鎖定height=2  
行2  [Q1] [ ]  [ ]  [ ]   ← SQUARE1下半部分
```

**✅ 成功避免混排！**

#### **實例分析2**: 4個SMALL + 1個SQUARE

**處理流程**：
```
題目順序: [SMALL1, SMALL2, SMALL3, SMALL4, SQUARE1]

處理4個SMALL:
- 全部放入行0 → 行0完全被height=1題目佔滿
- 行0鎖定為height=1

處理SQUARE1:
- 嘗試行0 → height=1，衝突 → 拒絕
- 嘗試行1 → 空行 → 放置(行1,列0)

最終結果:
     列0  列1  列2  列3
行0  [S1] [S2] [S3] [S4]  ← 鎖定height=1
行1  [Q1] [ ]  [ ]  [ ]   ← 鎖定height=2
行2  [Q1] [ ]  [ ]  [ ]   ← SQUARE1下半部分
```

**✅ 完美分離！**

#### **方案A評估**

**優點**：
- ✅ **100%避免混排**：絕對保證同行高度一致
- ✅ **邏輯清晰**：規則簡單易理解
- ✅ **實現可行**：只需追蹤每行的高度狀態
- ✅ **空間效率好**：在大多數情況下不浪費空間

**缺點**：
- ⚠️ **可能的空間浪費**：極端情況下可能導致行使用不均
- ⚠️ **需要額外狀態管理**：需要維護行高度信息

---

### **方案B：高度分層放置機制**

#### **核心邏輯**  
- 按高度將題目分組：height=1一組，height=2一組
- 不同高度組使用完全分離的行區域
- height=1優先使用前面的行，height=2使用後面的行

#### **實例分析**: 2個SMALL + 1個SQUARE

**處理流程**：
```
步驟1: 按高度分組
height=1組: [SMALL1, SMALL2]  
height=2組: [SQUARE1]

步驟2: 分配行區域
height=1組 → 行0開始
height=2組 → height=1組結束後的行開始

步驟3: 依序放置
處理height=1組:
- SMALL1 → (行0,列0)
- SMALL2 → (行0,列1)

處理height=2組:
- SQUARE1 → (行1,列0)  # 從height=1組後開始

最終結果:
     列0  列1  列2  列3
行0  [S1] [S2] [ ]  [ ]   ← height=1專用區
行1  [Q1] [ ]  [ ]  [ ]   ← height=2專用區開始
行2  [Q1] [ ]  [ ]  [ ]   ← SQUARE1下半部分
```

#### **方案B評估**

**優點**：
- ✅ **絕對分離**：不同高度永不混合
- ✅ **實現簡單**：不需複雜的衝突檢測
- ✅ **可預測性高**：佈局結果完全確定

**缺點**：
- ❌ **空間利用率低**：可能導致大量空白
- ❌ **不夠靈活**：無法適應複雜的題目組合
- ❌ **視覺效果差**：可能產生大片空白區域

---

### **方案C：動態衝突檢測機制**

#### **核心邏輯**
- 放置時實時檢測該行是否已有不同高度的題目
- 通過掃描目標行的所有佔用位置來判斷高度衝突
- 靈活處理各種情況

#### **實例分析**: 複雜混合情況

**假設題目序列**: [SMALL1, SQUARE1, SMALL2, WIDE1]

**處理流程**：
```
處理SMALL1:
- 檢查行0 → 空行 → 放置(行0,列0)

處理SQUARE1:
- 檢查行0 → 掃描發現(行0,列0)有height=1題目 → 衝突
- 檢查行1 → 空行 → 放置(行1,列0)

處理SMALL2:
- 檢查行0 → 掃描發現都是height=1 → 相容 → 放置(行0,列1)

處理WIDE1:  
- 檢查行0 → 掃描發現都是height=1 → 相容 → 放置(行0,列2)

最終結果:
     列0  列1  列2  列3
行0  [S1] [S2] [W1------] ← 全height=1
行1  [Q1] [ ]  [ ]  [ ]   ← height=2
行2  [Q1] [ ]  [ ]  [ ]   ← SQUARE1下半部分
```

#### **方案C評估**

**優點**：
- ✅ **最大靈活性**：能處理各種複雜組合
- ✅ **空間效率高**：最大化利用可用空間
- ✅ **適應性強**：可以處理未預期的題目順序

**缺點**：
- ⚠️ **實現複雜**：需要複雜的掃描和檢測邏輯
- ⚠️ **性能開銷**：每次放置都需要掃描整行
- ⚠️ **調試困難**：邏輯複雜，出錯時難以定位

---

## 📊 **方案綜合比較**

| 評估維度 | 方案A(行鎖定) | 方案B(分層) | 方案C(動態檢測) |
|---------|-------------|-----------|---------------|
| **避免混排** | ✅ 100%保證 | ✅ 100%保證 | ✅ 100%保證 |
| **空間效率** | 🟡 良好 | ❌ 較差 | ✅ 最優 |
| **實現複雜度** | 🟡 中等 | ✅ 簡單 | ❌ 複雜 |
| **靈活性** | 🟡 良好 | ❌ 較差 | ✅ 最優 |
| **可維護性** | ✅ 良好 | ✅ 良好 | ⚠️ 較差 |
| **性能** | ✅ 良好 | ✅ 最優 | 🟡 中等 |

---

## 🎯 **推薦方案**

### **主推薦：方案A（行高度鎖定機制）**

**理由**：
1. **平衡性最佳**：在各個維度都有不錯的表現
2. **風險可控**：實現複雜度適中，出錯機率低
3. **效果可靠**：100%避免混排，空間利用率良好
4. **易於擴展**：可以在此基礎上添加更多優化

### **備選方案：方案C（動態檢測）**

**適用場景**：
- 對空間利用率要求極高
- 有充足的開發和測試資源
- 需要處理非常複雜的題目組合

### **不推薦：方案B（分層放置）**

**原因**：
- 空間浪費過於嚴重
- 實際使用中可能產生大量空白
- 視覺效果可能不佳

---

## 🛠️ **實施計畫**

### **Phase 1：方案A原型實現**
- 實現行高度追蹤機制
- 修改can_place_at邏輯
- 基本功能測試

### **Phase 2：完善和優化**  
- 邊界情況處理
- 性能優化
- 全面測試

### **Phase 3：評估與迭代**
- 實際使用場景測試
- 根據結果考慮是否需要切換到方案C

---

**最終建議**：優先實施**方案A（行高度鎖定機制）**，作為穩定可靠的基礎方案。如果後續有更高要求，再考慮升級到方案C。