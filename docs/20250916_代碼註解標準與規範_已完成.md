# 代碼註解標準與規範

> **文檔目的**: 建立清晰的註解標準，確保代碼可讀性和維護性
> **建立日期**: 2025-09-16
> **適用範圍**: 所有數學測驗生成器代碼

## 🎯 **註解核心原則**

### **註解的核心理念：防止「代碼說bug話」**
> **重要觀點**: 代碼常會說bug話，註解是確保邏輯正確性的重要手段
> **平衡原則**: 自然語言與機器語言互相配合，讓閱讀者容易理解
> **實施策略**: 儘量註解，但必須是有效註解，避免冗餘和誤導

### **註解的目的**
註解應該回答以下問題：
1. **為什麼這樣做？** (WHY) - 設計決策的原因
2. **目的是什麼？** (WHAT FOR) - 這段代碼要達成什麼目標
3. **需要注意什麼？** (WATCH OUT) - 邊界條件、特殊情況、陷阱
4. **邏輯是否正確？** (LOGIC CHECK) - 確保代碼邏輯與預期一致

### **註解不應該做的事**
- ❌ 重複描述代碼在做什麼（代碼本身已經很清楚時）
- ❌ 說明歷史變化（「從A改成B」、「移除了X」）
- ❌ 純粹的口號式陳述（「這是最佳實踐」）
- ❌ 無法驗證的斷言（「已證實可靠」）

---

## ✅ **有效註解類型**

### **1. 數學邏輯註解：防止「代碼說bug話」**
**目的**: 確保數學概念正確實施，避免隱藏的邏輯錯誤

```python
# ✅ 數學定義域/值域檢查
def _calculate_arcsin_result(self, value):
    # arcsin定義域限制：value必須在[-1, 1]範圍內
    if not (-1 <= value <= 1):
        raise ValueError(f"arcsin輸入值{value}超出定義域[-1,1]")

    # 轉換為角度制：弧度 * 180 / π
    result_radians = math.asin(value)
    result_degrees = math.degrees(result_radians)

    # 確保結果在[-90°, 90°]範圍內（arcsin值域）
    return round(result_degrees)

# ✅ 特殊值映射確認
special_map = {
    0.5: 30,           # sin(30°) = 1/2
    0.7071: 45,        # sin(45°) = √2/2 ≈ 0.7071
    0.8660: 60         # sin(60°) = √3/2 ≈ 0.8660
}
```

### **2. 工具選擇說明**
**目的**: 指導未來開發者的技術選擇，說明為什麼選擇特定函式庫或工具

```python
# ✅ 技術決策說明
# 使用f字串而非模板系統：變化點少於3個，避免過度工程
question = f"計算：$\\arcsin({value:.3f})$"

# 使用Sympy確保LaTeX格式標準化，避免手動格式化錯誤
expr = sqrt(a) + sqrt(b) if is_addition else sqrt(a) - sqrt(b)
return f"${latex(expr)}$"

# 使用options.get()提供彈性配置，避免複雜驗證框架
self.max_value = options.get('max_value', 25)
```

**⚠️ 常見格式問題**:
```python
# ❌ 有無意義前綴標籤
# 設計理念註解：雙重根式使用Sympy生成，確保數學表達式完全正確

# ✅ 移除前綴，保留有價值的內容
# 使用Sympy生成雙重根式，確保數學表達式和LaTeX格式正確
```

### **3. 邊界條件和特殊處理**
**目的**: 提醒開發者注意特殊情況，防止運行時錯誤

```python
# ✅ 邊界條件檢查
def _select_random_value(self, func_type):
    if func_type in ['sin', 'cos']:
        # arcsin/arccos輸入值必須在[-1,1]，避免math.asin()錯誤
        return random.uniform(-1, 1)
    else:  # arctan
        # arctan可接受任意實數輸入，但限制範圍便於教學
        return random.uniform(-10, 10)

# ✅ 算法邏輯說明
# 確保非平凡情況（避免完全平方數導致化簡失敗）
while self._is_perfect_square(a * b):
    random.shuffle(values)
    a, b = values[:2]

# 減法時確保 a >= b，避免負數結果
if a < b:
    a, b = b, a

# ✅ 系統穩定性保障
# 確保至少有一種運算形式可用
if not (self.allow_addition or self.allow_subtraction):
    self.logger.warning("至少需要允許一種運算形式，自動啟用加法")
    self.allow_addition = True
```

### **4. LaTeX格式和Unicode防範**
**目的**: 確保PDF輸出正確，防止Unicode符號錯誤

```python
# ✅ LaTeX格式標準化
def _format_latex_output(self, func_name, value, result):
    # 雙反斜線確保LaTeX正確轉義，防止Unicode符號錯誤
    return f"$\\{func_name}^{{-1}}({value}) = {result}^\\circ$"

# ✅ LaTeX換行格式
# 使用LaTeX換行而非HTML標籤，避免PDF中顯示錯誤
return "\\\\[0.3em]".join(formatted_steps)

# ✅ 預設題目機制
# 預設題目確保系統穩定性，避免生成失敗時崩潰
def _get_fallback_question(self) -> Dict[str, Any]:
    return {
        'question': "計算：$\\arcsin(0.5)$",
        'answer': "$30^\\circ$",
        'explanation': "因為 $\\sin(30^\\circ) = 0.5$"
    }
```

---

## ❌ **無效註解類型**

### **1. 歷史對比類（完全禁止）**
```python
# ❌ 壞範例
# 設計理念註解：移除Pydantic過度工程，改用4行簡潔配置
# 修正：<br> → \\\\[0.3em]，確保LaTeX格式正確
# 從舊版複製核心邏輯，已證實數學正確性
```
**問題**: 未來開發者不知道歷史，這些對比毫無意義

### **2. 口號式註解（毫無價值）**
```python
# ❌ 壞範例
# 設計理念註解：LaTeX模版化是關鍵特色
# 設計理念註解：這是真正有價值的改進
# 設計理念註解：回歸直接有效的配置
```
**問題**: 純粹的價值判斷，沒有提供實用資訊

### **3. 代碼重複說明（冗餘）**
```python
# ❌ 壞範例
# 創建生成器實例
generator = DoubleRadicalSimplificationGenerator()

# 設定a和b的值
a, b = values[:2]

# 返回字典
return {"question": question, "answer": answer}
```
**問題**: 代碼本身已經很清楚，註解沒有增加任何資訊

### **4. 無法驗證的斷言**
```python
# ❌ 壞範例
# 已證實可靠的算法
# 最佳實踐的實現
# 完全正確的數學邏輯
```
**問題**: 這些斷言無法驗證，且可能誤導開發者

---

## 📋 **註解撰寫檢查清單**

### **撰寫註解前的自我檢查**
- [ ] 這個註解是否回答了「為什麼」？
- [ ] 這個註解是否幫助防止「代碼說bug話」？
- [ ] 不看註解，代碼邏輯是否可能被誤解？
- [ ] 這個註解對6個月後的我有幫助嗎？
- [ ] 新加入團隊的開發者能從這個註解學到什麼？
- [ ] 這個註解是否避免了歷史對比和價值判斷？
- [ ] 這個註解是否確保了數學邏輯的正確性？

### **特定場景指導**

#### **數學演算法註解**
```python
# ✅ 解釋數學概念和邊界條件
# 雙重根式化簡：√(c±d√e) = √a ± √b，需要a*b = e且a+b = c
def _validate_solution(self, a, b, c, d, e):
```

#### **技術選擇註解**
```python
# ✅ 說明工具選擇的原因
# 使用Sympy.latex()確保數學表達式符合LaTeX標準
# 避免手動字串拼接可能產生的語法錯誤
return f"${latex(expression)}$"
```

#### **錯誤處理註解**
```python
# ✅ 說明錯誤情況和處理策略
# 當Sympy計算失敗時，使用預設題目確保系統穩定
except Exception as e:
    self.logger.warning(f"計算失敗: {str(e)}")
    return self._get_fallback_question()
```

---

## 🔧 **註解維護原則**

### **定期清理**
- **每次重構時**: 檢查註解是否仍然準確和有用
- **代碼審查時**: 重點檢查新增註解的品質
- **文檔更新時**: 確保註解與實際代碼一致

### **註解風格統一**
```python
# ✅ 統一的註解風格
# 動詞開頭，描述目的：「使用X確保Y」、「檢查X避免Y」
# 簡潔明確，一般不超過一行
# 必要時可以多行，但要有邏輯結構

# 複雜邏輯的多行註解範例：
# 第一步：建立數學關係式
# 第二步：求解參數值
# 第三步：驗證解的有效性
```

---

## 📚 **最佳實踐範例**

### **完整方法的註解範例**
```python
def _select_valid_pair(self) -> tuple[int, int]:
    """選擇有效的a,b數對

    確保生成的題目有意義且可化簡。
    """
    values = list(range(1, self.max_value + 1))
    random.shuffle(values)
    a, b = values[:2]

    # 確保非平凡情況（避免完全平方數導致化簡失敗）
    while self._is_perfect_square(a * b):
        random.shuffle(values)
        a, b = values[:2]

    # 減法時確保 a >= b，避免負數結果
    if a < b:
        a, b = b, a

    return a, b
```

### **工具使用的註解範例**
```python
def _format_answer(self, a: int, b: int, is_addition: bool) -> str:
    """格式化答案字串

    使用Sympy確保LaTeX格式標準化。
    """
    # 使用Sympy.latex()避免手動格式化錯誤，確保數學表達式正確
    expr = sqrt(a) + sqrt(b) if is_addition else sqrt(a) - sqrt(b)
    return f"${latex(expr)}$"
```

---

## 🎯 **專案特定規範**

### **數學生成器特殊要求**
1. **數學概念解釋**: 複雜數學邏輯必須有清楚註解
2. **LaTeX格式說明**: 特殊LaTeX處理要說明原因
3. **邊界條件強調**: 數學運算的邊界條件要特別標註
4. **工具選擇指導**: 明確說明為何選擇特定數學庫（如Sympy、NumPy等）

### **格式vs內容區分原則**
- **內容有價值的註解**: 保留並修正格式問題
- **格式問題**: 移除「設計理念註解：」等無意義前綴
- **判斷標準**: 註解是否回答「為什麼」、「目的」、「注意事項」
- **修正方式**: 保留核心信息，簡化表達方式

### **禁用註解模式**
```python
# ❌ 完全禁止這些模式
# 設計理念註解：...
# 修正：原來A → 現在B
# 基於舊版/新版...
# 已證實/最佳實踐/完全正確...
```

---

## 📝 **實施建議**

### **現有代碼清理**
1. **立即清理**: 移除所有歷史對比和口號式註解
2. **保留有用**: 保留工具選擇說明和邏輯解釋
3. **補強缺失**: 為複雜邏輯補充「為什麼」的說明

### **新代碼要求**
1. **撰寫前思考**: 這個註解是否幫助防止「代碼說bug話」？
2. **重點註解**: 數學邏輯確認、工具選擇說明、邊界條件檢查、LaTeX格式防範
3. **平衡原則**: 自然語言與機器語言互相配合，確保可理解性
4. **定期檢查**: 確保註解準確且有用

---

## 📈 **更新記錄**

**2025-09-17 更新**:
- **核心理念**: 整合「代碼會說bug話」觀點
- **平衡原則**: 自然語言與機器語言互相配合
- **實施策略**: 儘量註解，但必須是有效註解
- **新增重點**: 數學邏輯註解、LaTeX格式防範

**建立完成**: 2025-09-16
**狀態**: ✅ 標準制定完成，已更新理念
**下一步**: 應用於三角函數生成器重寫計畫