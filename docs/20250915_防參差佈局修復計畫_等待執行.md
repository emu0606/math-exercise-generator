# 20250915_防參差佈局修復計畫_研擬中

> **專案**: 數學測驗生成器防參差佈局修復
> **建立時間**: 2025-09-15
> **計畫狀態**: 研擬中
> **修復策略**: 最小侵入式 + 舊版邏輯恢復

---

## 🎯 **修復目標與原則**

### **核心目標**
實現同一行內所有題目必須有相同高度的佈局機制，徹底解決視覺參差問題。

### **設計原則**
1. **舊版邏輯恢復**: 基於已驗證的三重機制邏輯
2. **最小侵入式**: 只修復關鍵問題，保持系統穩定
3. **height=1絕對優先**: 必須設置專用優先通道
4. **簡單有效**: 避免過度複雜的設計

---

## 📋 **問題分析總結**

### **已確認的核心問題**
1. **缺少預排序機制**: question_distributor.py 無按size預排序
2. **缺少行高度鎖定**: layout.py 無行高度狀態追蹤
3. **放置策略錯誤**: CompactStrategy 破壞高度一致性
4. **無height=1優先通道**: 缺少專用處理邏輯

### **必須恢復的舊版機制**
1. **預排序**: size升序排列，確保height=1題目優先處理
2. **height=1優先通道**: 專用第一階段處理邏輯
3. **行優先遍歷**: 外層循環行，內層循環列
4. **行高度鎖定**: 追蹤每行高度狀態，防止混排

---

## 🏗️ **詳細修復計畫**

### **階段一：預排序機制修復**
**文件**: `utils/orchestration/question_distributor.py`

#### **任務一A：修復平衡分配預排序**
**位置**: 第347-349行 `_balanced_distribution()` 方法

**原代碼**:
```python
# 打亂本回合內的題目順序
random.shuffle(round_questions)
ordered_questions.extend(round_questions)
```

**修復為**:
```python
# 回合內排序：size優先，topic次要 (隨機中帶點秩序)
round_questions.sort(key=lambda q: (q.get('size', 1), q.get('topic', '')))
ordered_questions.extend(round_questions)
```

#### **任務一B：修復隨機分配預排序**
**位置**: 第293-296行 `_random_distribution()` 方法

**原代碼**:
```python
shuffled = questions.copy()
random.shuffle(shuffled)
logger.debug("使用隨機分配策略")
return shuffled
```

**修復為**:
```python
# 先打亂獲得基本隨機性，再按size+topic排序確保秩序
sorted_questions = questions.copy()
random.shuffle(sorted_questions)  # 第一層隨機
sorted_questions.sort(key=lambda q: (q.get('size', 1), q.get('topic', '')))  # 分層秩序
logger.debug("使用隨機分配策略 (隨機中帶點秩序)")
return sorted_questions
```

---

### **階段二：行高度鎖定機制建立**
**文件**: `utils/core/layout.py`

#### **任務二A：擴展GridManager狀態追蹤**
**位置**: 第66-70行 `GridManager.__init__()` 方法

**添加**:
```python
# 行高度鎖定狀態追蹤 {page: [row_heights]}
# -1表示未鎖定，1表示height=1鎖定，2表示height=2鎖定
self._row_locked_heights: Dict[int, List[int]] = {}
```

#### **任務二B：更新頁面創建邏輯**
**位置**: 第78-82行 `create_page()` 方法

**添加**:
```python
# 初始化行高度鎖定狀態
self._row_locked_heights[page_number] = [-1] * self.grid_height
```

#### **任務二C：更新題目放置邏輯**
**位置**: 第135-141行 `place_at()` 方法末尾

**添加**:
```python
# 更新行鎖定狀態
if page in self._row_locked_heights:
    for r in range(row, row + height_cells):
        if r < len(self._row_locked_heights[page]):
            self._row_locked_heights[page][r] = height_cells

logger.debug(f"行高度鎖定更新：頁面 {page}, 行 {row}-{row+height_cells-1} 鎖定為 height={height_cells}")
```

#### **任務二D：添加行高度檢查方法**
**位置**: GridManager類末尾添加新方法

**添加**:
```python
def get_row_locked_height(self, page: int, row: int) -> int:
    """獲取指定行的已鎖定高度

    Args:
        page: 頁碼
        row: 行號

    Returns:
        已鎖定的高度，-1表示未鎖定
    """
    if (page in self._row_locked_heights and
        0 <= row < len(self._row_locked_heights[page])):
        return self._row_locked_heights[page][row]
    return -1

def can_place_with_height_check(self, page: int, row: int, col: int,
                               width_cells: int, height_cells: int) -> bool:
    """檢查是否可以放置（包含高度相容性檢查）

    Args:
        page: 頁碼
        row: 起始行
        col: 起始列
        width_cells: 寬度
        height_cells: 高度

    Returns:
        是否可以放置
    """
    # 基本空間檢查
    if not self.can_place_at(page, row, col, width_cells, height_cells):
        return False

    # 高度相容性檢查
    for r in range(row, row + height_cells):
        existing_height = self.get_row_locked_height(page, r)
        if existing_height != -1 and existing_height != height_cells:
            logger.debug(f"高度衝突：行 {r} 已鎖定為 height={existing_height}，無法放置 height={height_cells}")
            return False

    return True
```

---

### **階段三：佈局策略簡化修復**
**文件**: `utils/core/layout.py`

#### **設計討論結果**：
經過邏輯分析和風險評估，確認採用最簡潔有效的解決方案：
1. **預排序已確保順序**: height=1題目先處理，height=2題目後處理
2. **行高度鎖定確保分離**: 當height=2題目輪到處理時，height=1行已被鎖定
3. **策略統一簡化**: 移除CompactStrategy，統一使用TopLeftStrategy + 行高度鎖定檢查

#### **任務三A：移除CompactStrategy，統一使用TopLeftStrategy**
**位置**: 第272行 `LayoutEngine.__init__()` 方法

**原代碼**:
```python
# 設定放置策略
self.placement_strategy = placement_strategy or CompactStrategy()
```

**修復為**:
```python
# 設定放置策略 (移除CompactStrategy，統一使用簡潔的TopLeftStrategy)
self.placement_strategy = placement_strategy or TopLeftStrategy()
```

#### **任務三B：修改TopLeftStrategy加入高度檢查**
**位置**: 第195-212行 `TopLeftStrategy.find_position()` 方法

**原代碼**:
```python
def find_position(self, grid_manager: GridManager, page: int,
                 width_cells: int, height_cells: int) -> Optional[Tuple[int, int]]:
    """從左上角開始尋找位置"""
    max_row = grid_manager.grid_height - height_cells + 1
    max_col = grid_manager.grid_width - width_cells + 1

    for row in range(max_row):
        for col in range(max_col):
            if grid_manager.can_place_at(page, row, col, width_cells, height_cells):
                return (row, col)

    return None
```

**修復為**:
```python
def find_position(self, grid_manager: GridManager, page: int,
                 width_cells: int, height_cells: int) -> Optional[Tuple[int, int]]:
    """從左上角開始尋找位置（包含行高度鎖定檢查）"""
    max_row = grid_manager.grid_height - height_cells + 1
    max_col = grid_manager.grid_width - width_cells + 1

    for row in range(max_row):
        for col in range(max_col):
            if grid_manager.can_place_with_height_check(page, row, col, width_cells, height_cells):
                return (row, col)

    return None
```

#### **策略選擇論證結果**：
- **選定方案**: TopLeftStrategy + 預排序 + 行高度鎖定
- **捨棄方案**: CompactStrategy修復（複雜且無實質利用率優勢）
- **選擇理由**:
  1. 接口完全相容，零系統風險
  2. 邏輯簡潔，維護性高
  3. 與新架構完美配合，徹底解決參差問題
  4. 新架構下利用率差異≤5%，可忽略
- **風險評估**: 零風險，純粹的簡化和優化

#### **任務三C：移除CompactStrategy類定義**
**位置**: 第215-241行 `CompactStrategy` 類

**操作**: 完全移除CompactStrategy類定義，簡化代碼結構

---

### **階段四：佈局後題號重新分配與LaTeX生成器統一修復**
**問題確認**: 經深入分析發現，題號重新分配後的對應錯亂問題，根源在於三個LaTeX生成器使用了不同的資料源

#### **問題根源分析**:
```python
# pdf_orchestrator.py 中的調用
contents['questions'] = latex_generator.generate_question_tex(
    layout_results,     # ✅ 使用重新分配題號的完整結果
)
contents['answers'] = latex_generator.generate_answer_tex(
    ordered_questions,  # ❌ 使用原始順序的題目列表
)
contents['explanations'] = latex_generator.generate_explanation_tex(
    ordered_questions,  # ❌ 使用原始順序的題目列表
)
```

**結果**: 題目卷顯示重新分配的題號，但解答卷和詳解卷仍使用原始順序計算題號，造成對應錯亂

#### **任務四A：添加題號重新分配方法**
**位置**: LayoutEngine類末尾添加新方法

**簡化版重新分配方法**:
```python
def _reassign_question_numbers(self, layout_results: List[Dict[str, Any]],
                              questions_per_round: int = 0) -> List[Dict[str, Any]]:
    """根據佈局位置重新分配題號

    確保題號遵循左上到右下的自然順序：
    1. 頁面優先：第1頁 < 第2頁
    2. 行優先：同頁面內，上行 < 下行
    3. 列次要：同行內，左列 < 右列
    """
    if not layout_results:
        return layout_results

    logger.debug("開始根據佈局位置重新分配題號")

    # 按視覺位置排序：頁面 -> 行 -> 列
    sorted_results = sorted(layout_results, key=lambda x: (x['page'], x['row'], x['col']))

    # 重新分配題號
    for i, item in enumerate(sorted_results):
        if questions_per_round > 0:
            round_num = (i // questions_per_round) + 1
            question_num_in_round = (i % questions_per_round) + 1
        else:
            round_num = 1
            question_num_in_round = i + 1

        item['round_num'] = round_num
        item['question_num_in_round'] = question_num_in_round

    logger.info(f"題號重新分配完成：{len(sorted_results)} 道題目")
    return sorted_results
```

#### **任務四B：修改LayoutEngine.layout()方法**
**位置**: layout()方法結尾，在return前添加

```python
# 根據佈局位置重新分配題號
layout_results = self._reassign_question_numbers(layout_results, questions_per_round)
return layout_results
```

#### **任務四C：統一LaTeX生成器資料源**
**文件**: `utils/orchestration/pdf_orchestrator.py`
**位置**: 第295-302行

**修改前**:
```python
contents['answers'] = latex_generator.generate_answer_tex(
    ordered_questions, content_config.test_title, content_config.questions_per_round
)
contents['explanations'] = latex_generator.generate_explanation_tex(
    ordered_questions, content_config.test_title, content_config.questions_per_round
)
```

**修改後**:
```python
contents['answers'] = latex_generator.generate_answer_tex(
    layout_results, content_config.test_title, content_config.questions_per_round
)
contents['explanations'] = latex_generator.generate_explanation_tex(
    layout_results, content_config.test_title, content_config.questions_per_round
)
```

#### **任務四D：更新LaTeX生成器函數簽名**
**文件**: `utils/latex/generator.py`
**位置**: 第183行和第263行

**修改參數名稱以保持一致性**:
```python
def generate_answer_tex(self, layout_results: List[Dict[str, Any]], test_title: str, questions_per_round: int = 0) -> str:
    # 函數體邏輯無需修改，因為layout_results包含所有必要字段

def generate_explanation_tex(self, layout_results: List[Dict[str, Any]], test_title: str, questions_per_round: int = 0) -> str:
    # 函數體邏輯無需修改，因為layout_results包含所有必要字段
```

#### **解決方案論證**:
- **資料完整性**: layout_results包含ordered_questions的所有字段 (question, answer, explanation, size)
- **題號一致性**: 三卷都使用相同的question_num_in_round欄位
- **修改最小化**: 只需修改2個調用點 + 2個參數名，函數邏輯無需變更
- **零風險**: layout_results是ordered_questions的超集，完全向下兼容

---

## 🧪 **測試驗證計畫**

### **單元測試方案（自動化）**

#### **測試模組1：GridManager行高度鎖定機制**
```python
def test_row_height_locking():
    """測試行高度鎖定狀態追蹤"""
    gm = GridManager(4, 8)
    gm.create_page(1)

    # 測試初始狀態
    assert gm.get_row_locked_height(1, 0) == -1  # 未鎖定

    # 放置height=1題目
    gm.place_at(1, 0, 0, 1, 1)
    assert gm.get_row_locked_height(1, 0) == 1  # 鎖定為height=1

    # 測試height=2題目衝突檢測
    assert not gm.can_place_with_height_check(1, 0, 1, 1, 2)  # 應該拒絕
    assert gm.can_place_with_height_check(1, 0, 1, 1, 1)      # 應該允許

def test_height2_placement():
    """測試height=2題目佔用連續行"""
    gm = GridManager(4, 8)
    gm.create_page(1)

    # 放置height=2題目
    gm.place_at(1, 1, 0, 1, 2)
    assert gm.get_row_locked_height(1, 1) == 2  # 行1鎖定
    assert gm.get_row_locked_height(1, 2) == 2  # 行2也鎖定
```

#### **測試模組2：預排序機制驗證**
```python
def test_size_based_sorting():
    """測試按size預排序功能"""
    questions = [
        {"size": 3, "topic": "test"},  # SQUARE
        {"size": 1, "topic": "test"},  # SMALL
        {"size": 2, "topic": "test"},  # WIDE
        {"size": 4, "topic": "test"},  # MEDIUM
    ]

    distributor = QuestionDistributor()
    result = distributor._balanced_distribution(questions, 1, 4)

    # 驗證排序結果：size應該按1,2,3,4順序
    sizes = [q.get('size', 1) for q in result]
    assert sizes == [1, 2, 3, 4]

def test_height_grouping():
    """測試高度分組效果"""
    questions = [
        {"size": 3}, {"size": 1}, {"size": 4}, {"size": 2},  # 混合順序
    ]

    distributor = QuestionDistributor()
    result = distributor._balanced_distribution(questions, 1, 4)

    # 前兩題應該是height=1 (size 1,2)
    # 後兩題應該是height=2 (size 3,4)
    height_map = {1: 1, 2: 1, 3: 2, 4: 2}
    heights = [height_map[q.get('size', 1)] for q in result]
    assert heights == [1, 1, 2, 2]
```

#### **測試模組3：Height1Priority策略驗證**
```python
def test_height1_priority_stage1():
    """測試height=1優先通道"""
    gm = GridManager(4, 8)
    gm.create_page(1)
    strategy = Height1PriorityStrategy()

    # height=1題目應該優先獲得(0,0)位置
    pos = strategy.find_position(gm, 1, 1, 1)
    assert pos == (0, 0)

    # 放置後再測試下一個height=1題目
    gm.place_at(1, 0, 0, 1, 1)
    pos = strategy.find_position(gm, 1, 1, 1)
    assert pos == (0, 1)  # 同行下個位置

def test_height2_pushed_to_later_rows():
    """測試height=2題目被推到後面行"""
    gm = GridManager(4, 8)
    gm.create_page(1)
    strategy = Height1PriorityStrategy()

    # 先放置多個height=1題目佔據前面行
    gm.place_at(1, 0, 0, 1, 1)  # 行0
    gm.place_at(1, 0, 1, 1, 1)  # 行0

    # height=2題目應該被推到行1開始
    pos = strategy.find_position(gm, 1, 1, 2)
    assert pos[0] >= 1  # 行號應該>=1
```

#### **測試模組4：完整佈局流程測試**
```python
def test_complete_layout_flow():
    """測試完整佈局防參差效果"""
    layout_engine = LayoutEngine()

    questions = [
        {"size": 1, "question": "Q1", "answer": "A1", "explanation": "E1"},
        {"size": 1, "question": "Q2", "answer": "A2", "explanation": "E2"},
        {"size": 3, "question": "Q3", "answer": "A3", "explanation": "E3"},
        {"size": 3, "question": "Q4", "answer": "A4", "explanation": "E4"},
    ]

    results = layout_engine.layout(questions)

    # 驗證佈局結果
    assert len(results) == 4

    # height=1題目應該在前面行
    height1_questions = [r for r in results if r.get('size') in [1, 2]]
    height2_questions = [r for r in results if r.get('size') in [3, 4, 5, 6]]

    if height1_questions and height2_questions:
        min_height1_row = min(q['row'] for q in height1_questions)
        min_height2_row = min(q['row'] for q in height2_questions)

        # height=2題目的最小行號應該>=height=1題目的最小行號
        assert min_height2_row >= min_height1_row

def test_no_height_mixing_in_same_row():
    """測試同行不會混合不同高度"""
    layout_engine = LayoutEngine()

    questions = [
        {"size": 1, "question": "S1", "answer": "A1", "explanation": "E1"},
        {"size": 3, "question": "Q1", "answer": "A2", "explanation": "E2"},
        {"size": 1, "question": "S2", "answer": "A3", "explanation": "E3"},
    ]

    results = layout_engine.layout(questions)

    # 按行分組檢查高度一致性
    rows = {}
    for result in results:
        row = result['row']
        height = result['height_cells']

        if row not in rows:
            rows[row] = []
        rows[row].append(height)

    # 每行內所有題目高度必須相同
    for row_num, heights in rows.items():
        assert len(set(heights)) == 1, f"行 {row_num} 出現混合高度: {heights}"
```

### **測試案例設計（詳盡覆蓋）**

#### **基礎功能測試案例**

**案例1：基本防參差驗證**
```python
questions = [
    {"size": 1}, {"size": 1}, {"size": 3}  # 2個SMALL + 1個SQUARE
]
# 預期：行0放2個SMALL，行1-2放1個SQUARE
```

**案例2：滿行height=1測試**
```python
questions = [
    {"size": 1}, {"size": 1}, {"size": 1}, {"size": 1},  # 4個SMALL填滿行0
    {"size": 3}  # 1個SQUARE被推到行1
]
# 預期：行0完全被height=1佔滿，SQUARE被迫使用行1-2
```

**案例3：混合尺寸全覆蓋**
```python
questions = [
    {"size": 1}, {"size": 2},  # SMALL + WIDE (都是height=1)
    {"size": 3}, {"size": 4}, {"size": 5}, {"size": 6}  # 全部height=2
]
# 預期：前兩題同行，後四題分別佔用不同行位置
```

#### **邊界條件測試案例**

**案例4：單頁滿載測試**
```python
questions = [
    {"size": 1} for _ in range(16)  # 16個SMALL (4x8網格可容納32個1x1)
] + [
    {"size": 3} for _ in range(8)   # 8個SQUARE (每個2x1，共需16格)
]
# 預期：height=1題目佔據前4行，height=2題目佔據後4行
```

**案例5：強制分頁測試**
```python
questions = [
    {"size": 6} for _ in range(5)  # 5個EXTRA (每個4x2，超出單頁容量)
]
# 預期：自動分頁，測試分頁後行高度鎖定重置
```

**案例6：極端尺寸組合**
```python
questions = [
    {"size": 2}, {"size": 2},  # 2個WIDE (2x1)
    {"size": 5}, {"size": 6}   # LARGE(3x2) + EXTRA(4x2)
]
# 預期：WIDE佔據行0，LARGE和EXTRA分別佔用後續行
```

#### **回歸測試案例**

**案例7：回合制功能測試**
```python
questions = [
    {"size": 1}, {"size": 3}, {"size": 1}, {"size": 3}  # 交替尺寸
]
# 測試：questions_per_round=2，確保回合邊界正確處理
```

**案例8：錯誤容錯測試**
```python
questions = [
    {"size": 999},  # 無效尺寸
    {"size": None}, # 空尺寸
    {},             # 無size欄位
    {"size": 1}     # 正常尺寸
]
# 預期：錯誤題目使用預設尺寸，不影響整體佈局
```

**案例9：空題目處理**
```python
questions = []  # 空列表
# 預期：正常處理，不崩潰
```

### **性能測試案例**

**案例10：大量題目性能測試**
```python
questions = [
    {"size": random.choice([1,2,3,4,5,6])} for _ in range(1000)
]
# 測試：1000題佈局，記錄處理時間和記憶體使用
```

### **測試執行指令**

```bash
# 單元測試執行
py -m pytest tests/test_utils/test_core/test_layout.py -v
py -m pytest tests/test_utils/test_orchestration/test_question_distributor.py -v

# 完整測試套件
py -m pytest tests/ -v --tb=short

# 測試覆蓋率檢查
py -m pytest tests/ --cov=utils --cov-report=html
```

### **驗證方法**

#### **自動化驗證**
1. **單元測試**: 各個功能模組獨立測試
2. **集成測試**: 完整流程端到端測試
3. **性能測試**: 響應時間和記憶體使用監控
4. **覆蓋率測試**: 確保代碼覆蓋率>85%

#### **人工驗證（由您處理）**
1. **整合測試**: 完整PDF生成流程測試
2. **視覺驗證**: 生成HTML佈局圖進行人工確認
3. **用戶體驗測試**: 實際使用場景驗證
4. **對比測試**: 與修復前結果比較

---

## 📅 **實施時程安排**

### **Day 1: 核心機制實施**
- **上午**: 階段一 + 階段二 (預排序 + 行高度鎖定)
- **下午**: 階段三 (策略簡化 - 統一使用TopLeftStrategy)

### **Day 2: 完善與測試**
- **上午**: 階段四 (題號重新分配系統)
- **下午**: 單元測試 + 整合測試 + 視覺驗證

### **預計完成時間**: 2個工作日

---

## 🎯 **成功標準定義**

### **功能標準**
- [ ] **100%消除同行混合高度**: 絕對不允許height=1和height=2同行
- [ ] **正確的題目順序**: height=1題目優先，height=2題目後置
- [ ] **空間利用率**: 保持≥80%利用率
- [ ] **系統穩定性**: 所有現有功能正常運作

### **測試標準**
- [ ] **標準測試案例**: 所有測試案例100%通過
- [ ] **邊界測試**: 極端情況正確處理
- [ ] **回歸測試**: 不破壞現有功能
- [ ] **性能測試**: 響應時間不超過基準110%

---

## 🚨 **風險評估與緩解**

### **主要風險點**
1. **GridManager狀態追蹤複雜化**: 可能影響現有邏輯
   - **緩解**: 向後相容性檢查，添加完整的容錯機制

2. **Height1Priority策略破壞現有佈局**: 可能影響特殊場景
   - **緩解**: 保留原策略作為備選，提供策略切換機制

3. **預排序影響題目隨機性**: 可能影響用戶預期
   - **緩解**: 在size組內保持隨機，只在size間排序

### **回滾準備**
- **代碼備份**: 修改前自動備份
- **快速回滾**: 準備一鍵恢復腳本
- **分階段部署**: 每個階段獨立可回滾

---

## 📋 **實施檢查清單**

### **修改前準備**
- [ ] 確認當前git狀態clean
- [ ] 運行完整測試套件確認基準
- [ ] 備份關鍵文件

### **階段一檢查**
- [ ] question_distributor.py預排序邏輯正確
- [ ] 排序結果符合預期（height=1優先）
- [ ] 不破壞現有分配功能

### **階段二檢查**
- [ ] GridManager正確追蹤行高度狀態
- [ ] place_at()正確更新鎖定狀態
- [ ] 高度檢查方法工作正常

### **階段三檢查**
- [ ] Height1PriorityStrategy雙階段邏輯正確
- [ ] height=1題目確實優先獲得前面位置
- [ ] height=2題目被正確推到後面行

### **階段三檢查**
- [ ] TopLeftStrategy成功設為預設策略
- [ ] 高度相容性檢查邏輯正確
- [ ] CompactStrategy已移除或停用

### **階段四檢查**
- [ ] 題號重新分配邏輯正確
- [ ] 視覺順序符合左上到右下期望
- [ ] 回合制模式兼容性良好

---

---

## 📝 **討論過程記錄**

### **2025-09-15 討論紀要**

#### **階段一：預排序機制 - 確認通過**
- **採用「隨機中帶點秩序」哲學**: 如史提夫賈伯斯所言，在隨機中帶點秩序
- **分層排序策略**: size優先 → topic次要 → 隨機性保留在同條件內
- **實現邏輯**: `sort(key=lambda q: (q.get('size', 1), q.get('topic', '')))`
- **風險評估**: 低風險，邏輯簡單清晰

#### **階段二：行高度鎖定機制 - 確認通過**
- **核心邏輯**: 追蹤每行的height狀態，防止混合高度
- **狀態管理**: `-1`(未鎖定) → `1`(height=1鎖定) → `2`(height=2鎖定)
- **檢查機制**: `can_place_with_height_check()` 確保相容性
- **風險評估**: 低風險，邏輯清晰且必要

#### **階段三：搜尋策略 - 簡化為TopLeft+鎖定檢查**
- **原方案**: 複雜的Height1Priority雙階段策略
- **簡化方案**: TopLeftStrategy + 行高度鎖定檢查
- **論證**: 預排序+行鎖定已確保分離，無需複雜邏輯
- **搜尋優化**: 討論每格從(0,0)開始的必要性，確認簡單策略的穩定性
- **風險評估**: 低風險，簡化邏輯更穩定

### **已討論完成階段**
- **階段一**: 預排序機制 - ✅ 確認通過
- **階段二**: 行高度鎖定機制 - ✅ 確認通過
- **階段三**: 佈局策略簡化 - ✅ 確認通過 (移除CompactStrategy)
- **階段四**: 題號重新分配與LaTeX統一修復 - ✅ 確認通過

---

**計畫狀態**: ✅ 全部四階段討論完成，計畫就緒
**下一階段**: 等待實施命令
**風險等級**: 🟡 中風險（涉及核心邏輯修改，但基於已驗證設計）